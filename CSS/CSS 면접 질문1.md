- [Resett CSS와 Normalize CSS의 차이점은 무엇인가? 당신은 무엇을 선택할 것이며, 그 이유는 무엇인가?](#resett-css와-normalize-css의-차이점은-무엇인가-당신은-무엇을-선택할-것이며-그-이유는-무엇인가)
  - [예시](#예시)
  - [어떤 걸 선택해야 할까?](#어떤-걸-선택해야-할까)
  - [참고 - 요즘 트렌드는?](#참고---요즘-트렌드는)
- [float가 어떻게 작동하는지 설명하세요.](#float가-어떻게-작동하는지-설명하세요)
  - [기본 흐름](#기본-흐름)
  - [문제점](#문제점)
  - [정리](#정리)
- [BFC(Block Formatting Context)와 그 작동 방식을 설명하라](#bfcblock-formatting-context와-그-작동-방식을-설명하라)
- [clear 하는 방법에는 어떤 것이 있으며, 각각 어떤 상황에 적합한가요?](#clear-하는-방법에는-어떤-것이-있으며-각각-어떤-상황에-적합한가요)
- [브라우저 별로 스타일이 다른 문제를 어떤 접근 방법으로 해결하는가?](#브라우저-별로-스타일이-다른-문제를-어떤-접근-방법으로-해결하는가)
- [기능이 제한된 브라우저의 페이지는 어떻게 처리하는가? 어떤 기술/프로세스를 사용하는가?](#기능이-제한된-브라우저의-페이지는-어떻게-처리하는가-어떤-기술프로세스를-사용하는가)
  - [기능이 제한된 브라우저란?](#기능이-제한된-브라우저란)
  - [처리 전략](#처리-전략)
  - [구체적 기술 및 도구](#구체적-기술-및-도구)
  - [정리](#정리-1)
- [콘텐츠를 시각적으로 숨기는(그리고 screen reader에서만 사용할 수 있게 만드는) 다양한 방법은 무엇인가?](#콘텐츠를-시각적으로-숨기는그리고-screen-reader에서만-사용할-수-있게-만드는-다양한-방법은-무엇인가)
- [screen이 아닌 @media 속성은 무엇이 있는가?](#screen이-아닌-media-속성은-무엇이-있는가)
- [WAI-ARIA란?](#wai-aria란)
- [효율적인 CSS 작성 방법은?](#효율적인-css-작성-방법은)
  - [🔥 추가로 조심할 것](#-추가로-조심할-것)
    - [너무 구체적인 선택자(depth 3~4 이상) 만들지 말기](#너무-구체적인-선택자depth-34-이상-만들지-말기)
    - [id 셀렉터보다 클래스 기반으로 스타일링](#id-셀렉터보다-클래스-기반으로-스타일링)
    - [글로벌 스타일 오염(충돌) 방지](#글로벌-스타일-오염충돌-방지)
- [실전에서 어떤 CSS 구조를 선택하는 게 좋을까?](#실전에서-어떤-css-구조를-선택하는-게-좋을까)
- [reflow, repaint, compositing은 무엇이며 일어나는 경우는?](#reflow-repaint-compositing은-무엇이며-일어나는-경우는)
  - [Reflow를 많이 유발하는 코드 패턴](#reflow를-많이-유발하는-코드-패턴)
    - [✨ 최적화 방법](#-최적화-방법)
  - [Repaint만 발생시키는 CSS 속성 리스트](#repaint만-발생시키는-css-속성-리스트)
    - [✨ 주의할 점](#-주의할-점)
  - [정리](#정리-2)
- [CSS 전처리기를 사용하면 어떤 장단점이 있는가?](#css-전처리기를-사용하면-어떤-장단점이-있는가)
- [브라우저가 CSS 선택자에 일치하는 요소를 어떻게 결정하는지 설명하시오](#브라우저가-css-선택자에-일치하는-요소를-어떻게-결정하는지-설명하시오)
  - [매칭 성능을 느리게 만드는 선택자들](#매칭-성능을-느리게-만드는-선택자들)
  - [선택자 최적화 방법](#선택자-최적화-방법)
  - [좋은 선택자 vs 나쁜 선택자 비교](#좋은-선택자-vs-나쁜-선택자-비교)
- [반응형 디자인은 적응형 디자인과 어떻게 다른가?](#반응형-디자인은-적응형-디자인과-어떻게-다른가)
- [absolute 포지셔닝 대신 translate()를 사용하는 이유가 무엇인가? 또는 그 반대의 경우에 대해서는 어떻게 생각하는가? 그 이유는 무엇인가?](#absolute-포지셔닝-대신-translate를-사용하는-이유가-무엇인가-또는-그-반대의-경우에-대해서는-어떻게-생각하는가-그-이유는-무엇인가)
  - [translate()를 사용하는 이유](#translate를-사용하는-이유)
  - [absolute를 쓰는 경우](#absolute를-쓰는-경우)
  - [정리](#정리-3)
- [CSS 애니메이션과 JS 애니메이션의 차이점](#css-애니메이션과-js-애니메이션의-차이점)
- [Flex와 Grid의 차이점에 대해서 설명하시오](#flex와-grid의-차이점에-대해서-설명하시오)

<br/>
<br/>

# Resett CSS와 Normalize CSS의 차이점은 무엇인가? 당신은 무엇을 선택할 것이며, 그 이유는 무엇인가?

<br/>

| 항목                 | Reset CSS                                                      | Normalize CSS                                                  |
| -------------------- | -------------------------------------------------------------- | -------------------------------------------------------------- |
| **목적**             | 브라우저 기본 스타일 **초기화 (삭제)**                         | 브라우저 기본 스타일을 **일관되게 정리**                       |
| **스타일 처리 방식** | 대부분의 요소 스타일을 0으로 **강제로 초기화**                 | 브라우저 스타일을 **보존하면서 통일성 있게 조정**              |
| **예시**             | `margin: 0`, `padding: 0`, `border: 0` 등으로 모든 요소 초기화 | 기본 스타일 유지하되, **버그 수정/브라우저 간 차이 보정** 중심 |
| **대표 도구**        | Eric Meyer's Reset                                             | normalize.css (by Nicolas Gallagher)                           |
| **장점**             | 완전히 새로 스타일을 설계할 때 유리                            | 브라우저 기본 스타일을 활용 가능 (ex: `<button>`, `<h1>` 등)   |
| **단점**             | 모든 요소가 "완전 초기 상태"가 되므로 **불필요한 재정의** 발생 | 스타일이 일부 남아 있어서 완전한 통제에는 불리할 수 있음       |

## 예시

<h3>Reset CSS</h3>

완전히 비워진 상태에서 시작하여 디자인 시스템을 하나하나 다시 정의할 때 유리

```
/* Eric Meyer's Reset */
html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp,
... {
  margin: 0;
  padding: 0;
  border: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline;
}
```

<h3>Normalize CSS</h3>

브라우저 기본 스타일을 최대한 보존하면서 문제가 되는 부분만 고침. 특히 폰트, form 요소, heading, table 등에 집중

```
/* normalize.css 일부 예 */
html {
  line-height: 1.15;
  -webkit-text-size-adjust: 100%;
}
body {
  margin: 0;
}
button {
  font-family: inherit;
  font-size: 100%;
}
```

## 어떤 걸 선택해야 할까?

| 상황                                                                 | 추천 방식                               |
| -------------------------------------------------------------------- | --------------------------------------- |
| 완전히 내 스타일 시스템으로 모든 걸 직접 정의하고 싶을 때            | ✅ Reset CSS                            |
| 브라우저 간 기본 스타일은 유지하고, 브라우저 일관성만 맞추고 싶을 때 | ✅ Normalize CSS                        |
| 프레임워크 사용 (Tailwind, Bootstrap 등)                             | 대부분 내부적으로 Normalize 기반 포함됨 |
| 접근성과 기본 요소 스타일이 중요한 프로젝트 (예: CMS, 블로그)        | Normalize CSS 추천                      |

## 참고 - 요즘 트렌드는?

많은 프로젝트에서 불필요하게 과도한 reset은 지양하고, 필요한 부분만 깔끔하게 초기화하는 Reset + Normalize 절충 방식을 사용한다.

```
*, *::before, *::after {
  box-sizing: border-box;
}
body, h1, h2, h3, h4, p, figure, blockquote, dl, dd {
  margin: 0;
}
```

</br>
</br>

# float가 어떻게 작동하는지 설명하세요.

`float`는 CSS 위치 지정 속성으로 요소를 왼쪽이나 오른쪽으로 띄워서, 주변 텍스트나 요소가 그 옆으로 흐르도록 만든다.

예전부터 사용되던 CSS 속성 중 하나로, 레이아웃 배치나 이미지 정렬 등에 자주 쓰였지만 지금은 Flexbox나 Grid에 밀려 사용이 줄었다.

```
float: left;
float: right;
float: none;
float: inline-start;
float: inline-end;
```

## 기본 흐름

float된 요소는 문서 흐름에서 벗어나게 됨 (out of normal flow)

그래서 부모 요소가 float된 자식의 높이를 인식하지 못하는 문제가 자주 생김

float된 요소 옆으로 다른 요소(특히 텍스트)가 흐르듯 감싸서 배치됨

```
<img src="image.jpg" style="float: left; margin-right: 10px;" />
<p>이 텍스트는 이미지의 오른쪽으로 흐르며 감싸집니다.</p>
```

## 문제점

❌ 부모 요소가 높이 계산 못함

```
<div class="parent">
  <div class="child" style="float: left;">내용</div>
</div>
```

parent는 자식이 float 상태라 높이가 0으로 collapse됨

해결법: clearfix 사용

✅ clearfix 예시 (현대식)

<!-- ? -->

```
.parent::after {
  content: "";
  display: table;
  clear: both;
}
```

## 정리

| 항목                | 설명                                                       |
| ------------------- | ---------------------------------------------------------- |
| `float: left/right` | 요소를 왼쪽/오른쪽으로 띄워 옆에 텍스트나 요소가 흐르게 함 |
| 문서 흐름           | 빠져나감 (부모 높이 collapse 주의)                         |
| 해결책              | `clearfix`로 부모 높이 복원                                |
| 대체 기술           | Flexbox, Grid (현대 레이아웃 대부분 이걸로 처리함)         |
| 남아 있는 용도      | 이미지와 텍스트 조합, 일부 특수 레이아웃                   |

**[css-tricks all about floats]**

https://css-tricks.com/all-about-floats/

</br>
</br>

# BFC(Block Formatting Context)와 그 작동 방식을 설명하라

<!--  -->

</br>
</br>

# clear 하는 방법에는 어떤 것이 있으며, 각각 어떤 상황에 적합한가요?

<!--  -->

빈 div 방법 - <div style="clear:both;"></div>
Clearfix 방법 - 위 .clearfix 클래스를 참조하세요.
overflow: auto 또는 overflow: hidden 방법 - 부모는 새로운 Block Formatting Context를 설정하고, 확장된 자식을 포함하도록 합니다.
대규모의 프로젝트에서는 유용하게 .clearfix 클래스를 만들어 필요한 곳에서 사용합니다. 자식이 부모보다 크기가 큰 경우 overflow: hidden은 자식을 모두 보여줄 수 없습니다.

</br>
</br>

<!-- # CSS 스프라이트는 무엇인가? 그리고 당신이 페이지나 사이트에 구현하는 방법도 설명해 주세요. -->

<!--  -->

# 브라우저 별로 스타일이 다른 문제를 어떤 접근 방법으로 해결하는가?

1. ✅ CSS Reset 또는 Normalize.css 사용

   Reset CSS : 브라우저 기본 스타일을 모두 제거해서 제로 베이스에서 시작

   Normalize.css : 브라우저 스타일을 통일되게 정리해서 일관성 확보

   📌 Reset은 완전 초기화, Normalize는 기본 유지 + 보정

   🔧 요즘은 둘을 적절히 혼합한 방식도 자주 사용된다.

2. ✅ CSS 전처리기/유틸 프레임워크 활용

   Tailwind CSS, Bootstrap, MUI 등은 이미 브라우저 간 차이점을 흡수하도록 설계됨

   기본 스타일이 통일되어 있어서 브라우저 차이가 줄어듦

3. ✅ 벤더 프리픽스 자동 처리
   각 브라우저의 고유 접두사(-webkit-, -moz- 등)를 수동으로 쓰지 말고 Autoprefixer를 PostCSS와 함께 사용해서 자동 처리

   ```
   /_ 작성 예 _/
   display: flex;
   /_ → 컴파일 후 _/
   display: -webkit-box;
   display: -ms-flexbox;
   display: flex;
   ```

4. ✅ 크로스 브라우징 테스트

   실제 브라우저에서 직접 확인하거나

   브라우저 테스트 툴 사용:

   BrowserStack

   CrossBrowserTesting

   개발자 도구에서 유저 에이전트 변경도 가능

5. ✅ feature detection: Modernizr

   브라우저마다 지원하는 기능이 다를 수 있음

   Modernizr를 통해 해당 기능 지원 여부를 탐지하고 대체 스타일 제공 가능

6. ✅ 조건부 스타일 또는 JS 처리

   ```
   @supports (display: grid) {
       .container {
       display: grid;
       }
   }

   @media (-webkit-min-device-pixel-ratio: 0) {
   /_ WebKit 전용 스타일 _/
   }
   ```

   특정 브라우저 전용 스타일도 가능하지만 너무 많이 쓰면 유지보수 어려움 ⚠️

✅ 정리 요약

| 방법                  | 설명                                      |
| --------------------- | ----------------------------------------- |
| CSS Reset / Normalize | 기본 스타일을 제거하거나 일관성 있게 정리 |
| CSS 프레임워크 사용   | 이미 브라우저 차이를 흡수한 스타일 제공   |
| Autoprefixer 사용     | 접두사 자동 추가로 호환성 확보            |
| 실제 테스트           | 다양한 브라우저에서 직접 확인             |
| Modernizr 등 탐지     | 지원 여부 감지 후 처리                    |
| 조건부 CSS            | 특정 브라우저/기능 전용 스타일 적용       |

</br>
</br>

# 기능이 제한된 브라우저의 페이지는 어떻게 처리하는가? 어떤 기술/프로세스를 사용하는가?

<!--  -->

기능이 제한된 브라우저에서 페이지를 처리하는 건 웹 접근성, 유연한 사용자 경험, 그리고 점진적 향상(progressive enhancement) 또는 우아한 퇴화(graceful degradation) 같은 개념과 밀접하게 연결된다.

## 기능이 제한된 브라우저란?

- 오래된 브라우저 (예: IE11 이하, 구형 Android 브라우저 등)

- JavaScript 비활성화된 환경

- CSS 최신 기능을 지원하지 않는 브라우저

- 저사양 기기에서의 제한된 성능

## 처리 전략

| 전략                                     | 설명                                                        |
| ---------------------------------------- | ----------------------------------------------------------- |
| 🧱 점진적 향상 (Progressive Enhancement) | 기본 기능은 단순하게, 최신 브라우저는 풍부한 기능 추가      |
| 💨 우아한 퇴화 (Graceful Degradation)    | 최신 기능 위주로 개발하되, 낡은 브라우저에서 적절히 degrade |
| 🧪 기능 감지 (Feature Detection)         | 브라우저 기능을 탐지해서 조건부 코드 실행 (Modernizr 등)    |
| 🛑 폴리필 (Polyfill) 사용                | 지원 안 되는 기능을 JS로 에뮬레이션 (예: fetch, Promise)    |
| 🧼 Fallback 디자인                       | CSS나 JS 기능이 실패했을 때 기본 스타일/경고 메시지 제공    |
| 📉 성능 최적화                           | JS 과도하게 쓰지 않고 경량화, 요청 최소화                   |

## 구체적 기술 및 도구

<!-- 정리필 -->

1.  HTML 기본 구조 보장
    JS 없이도 핵심 정보/기능에 접근 가능하게 구성

    ```
    <noscript>
    <p>이 사이트는 JavaScript가 꺼져 있으면 일부 기능이 제한됩니다.</p>
    </noscript>
    ```

2.  Modernizr 사용 (기능 감지)

    ```
    if (!Modernizr.flexbox) {
      // flexbox 지원 안되면 fallback layout 적용
    }
    ```

3.  Polyfill.io 또는 직접 폴리필 제공

    ```
    <script src="https://polyfill.io/v3/polyfill.min.js?features=fetch%2CPromise"></script>
    ```

    ➡️ 브라우저가 지원하지 않는 기능만 자동으로 골라서 제공

4.  조건부 CSS 적용
    <!-- CSS Feature 쿼리?  -->

    ```
    @supports (display: grid) {
      .layout {
        display: grid;
      }
    }
    ```

    ➡️ CSS 기능 지원 여부에 따라 대응 스타일 분기 가능

5.  CSS Fallback

    ```
    .element {
      background: url('fallback.jpg');
      background: image-set(url('highres.webp') type('image/webp') 2x);
    }
    ```

6.  React, Vue 등에서도 코드 분기

    ```
    if (!window.CSS || !CSS.supports('display', 'grid')) {
      // polyfill layout 로드하거나 메시지 출력
    }
    ```

    <!--
    우아한 퇴보 - 최신 브라우저를 위한 어플리케이션을 구축하는 동시에 그것이 구형 브라우저에서도 계속 작동하도록 하는 구축 방법.
    점진적 향상 - 기본 수준의 사용자 환경에 대한 응용 프로그램을 구축하지만 브라우저가 이를 지원할 경우 기능을 강화하는 방법.
    caniuse.com을 사용하여 기능 지원을 확인합니다.
    자동 벤더 프리픽스 삽입을 위해 Autoprefixer 사용.
    Modernizr를 사용하여 기능 감지.
    CSS Feature 쿼리 @support 사용. -->

## 정리

| 접근 방식               | 설명                                                     |
| ----------------------- | -------------------------------------------------------- |
| Progressive Enhancement | 기본 기능을 보장하고, 최신 브라우저에서만 고급 기능 사용 |
| Graceful Degradation    | 최신 기능을 쓰되, 구형 브라우저에선 단순 대체 제공       |
| Feature Detection       | 지원 여부 체크 후 분기 처리 (Modernizr 등)               |
| Polyfill                | 미지원 기능을 JS로 흉내냄 (fetch, Promise 등)            |
| CSS Fallback            | 고급 기능 실패 시 기본 스타일 제공                       |
| 성능 최적화             | 구형 브라우저일수록 부하 줄이기                          |

</br>
</br>

# 콘텐츠를 시각적으로 숨기는(그리고 screen reader에서만 사용할 수 있게 만드는) 다양한 방법은 무엇인가?

<!--  -->

화면에서는 보이지 않지만, **스크린 리더(screen reader)** 에게는 보이도록 하는 건 웹 접근성(Accessibility, a11y)에서 정말 중요한 기술이다.

| 방법                                  | 설명                              | 스크린 리더에서 읽힘 |
| ------------------------------------- | --------------------------------- | -------------------- |
| `.sr-only` 클래스                     | 시각적으로 숨기고 음성으로만 제공 | ✅ 가능              |
| `aria-label`                          | 아이콘 등에서 대체 텍스트 제공    | ✅ 가능              |
| `aria-labelledby`, `aria-describedby` | 다른 숨겨진 텍스트를 참조해 설명  | ✅ 가능              |
| `display: none`, `visibility: hidden` | 완전히 숨김                       | ❌ 불가              |
| `inert` 속성                          | 요소를 포커스와 접근에서 제외     | ❌ 불가              |

1. visually-hidden (클래식한 접근)
   가장 많이 쓰이는 방법으로, 아래 CSS를 공통 클래스 .sr-only로 만들어 사용해.

   ```
   .sr-only {
   position: absolute;
   width: 1px;
   height: 1px;
   padding: 0;
   margin: -1px;
   overflow: hidden;
   clip: rect(0, 0, 0, 0);
   white-space: nowrap;
   border: 0;
   }
   ```

✅ 스크린 리더는 읽을 수 있고, 화면에는 보이지 않음
✅ Bootstrap, Tailwind 등에서도 기본 제공됨

2. aria-label 속성 사용 (짧은 텍스트인 경우)

   ```
   <button aria-label="닫기">✖</button>
   ```

   ✅ 시각적으로는 아이콘만 보이고, 스크린 리더는 텍스트 읽음
   ❗ 복잡한 설명이 필요한 경우에는 부적합

3. aria-labelledby / aria-describedby

   ```
   <span id="desc" class="sr-only">이미지를 확대하여 볼 수 있습니다</span>
   <img src="..." aria-describedby="desc" />
   ```

   ✅ 보이지 않는 설명 텍스트를 연결해줄 때 유용

4. display: none, visibility: hidden

   ```
   .hidden {
    display: none;
   }
   ```

   ❌ 스크린 리더에서도 읽을 수 없음 → 완전 숨김

5. inert 속성 (실험적)

   ```
   <div inert>이 영역은 무시됩니다</div>
   ```

✅ 포커스도 안 가고, 스크린 리더도 무시
❗ 시각적으로 숨기려는 목적과는 다름

<!-- width: 0; height: 0. 요소가 화면의 어떤 공간도 차지하지 않도록 합니다. 결과적으로 보이지 않게 됩니다.
position: absolute; left: -99999px. 화면 외부에 배치합니다.
text-indent: -9999px. 이것은 block인 요소 내의 텍스트에서만 작동합니다.
메타데이터. 예를 들면, Schema.org, RDF, JSON-LD를 사용합니다.
WAI-ARIA. 웹 페이지의 Accessibility를 높이는 방법을 정의하는 W3C 기술 사양입니다.
WAI-ARIA가 이상적인 해결책이라 하더라도 저는 absolute 위치 지정 접근 방법을 택할 것입니다. 대부분의 요소에 작동하며 간단한 기술이기 때문입니다. -->

# screen이 아닌 @media 속성은 무엇이 있는가?

@media 속성은 screen 을 포함하여 3가지 타입이 있다.

- all - 모든 미디어 기기 장치
- print - 프린터
- screen - 컴퓨터 스크린, 태블릿, 스마트폰 등
- print 미디어 타입의 사용 예제:

```
@media print {
  body {
    color: black;
  }
}
```

`speech` 미디어 타입은 CSS2.1에 있었지만, 현재는 브라우저 미지원 상태. 실무에서는 사용하지 말고, 웹 접근성은 CSS가 아닌 ARIA 등으로 처리하는 것이 표준.

# WAI-ARIA란?

<!--  -->

# 효율적인 CSS 작성 방법은?

| 방법                              | 설명                                                                |
| --------------------------------- | ------------------------------------------------------------------- |
| 구조적 설계 (BEM, OOCSS 등)       | 일관된 네이밍 규칙과 컴포넌트 기반 설계로 유지보수 용이             |
| 불필요한 중복 제거                | 중복 스타일 최소화, 재사용 가능한 클래스화                          |
| 레이어링 (Layered CSS)            | reset → base → layout → components → utilities 순서로 관리          |
| CSS 변수 사용 (Custom Properties) | 테마, 색상, 간격 등을 변수로 관리해서 일관성 유지                   |
| 작은 파일로 모듈화                | 기능 단위로 분리 (예: Button.css, Card.css)                         |
| 미디어 쿼리 정리                  | 관련 요소 옆에 media query를 같이 작성해서 응집성 높이기            |
| 최신 CSS 기능 활용                | grid, flexbox, container queries, logical properties 적극 활용      |
| 스타일 가드라인 따르기            | Prettier, Stylelint 등 도구로 코드 포맷/규칙 자동화                 |
| 퍼포먼스 최적화                   | 불필요한 셀렉터 깊이 제거, 가벼운 선택자 사용                       |
| CSS-in-JS (선택적)                | 규모가 클 때 styled-components, Tailwind, Vanilla Extract 사용 고려 |

</br>

## 🔥 추가로 조심할 것

### 너무 구체적인 선택자(depth 3~4 이상) 만들지 말기

<!--  -->

| 이유                                 | 설명                                                                  |
| ------------------------------------ | --------------------------------------------------------------------- |
| 유지보수 어려움                      | 구조가 조금만 바뀌어도 CSS 수정이 필수, 재사용성 낮아짐               |
| 우선순위 충돌 (Specificity Conflict) | 나중에 덮어쓰려면 더 강한 셀렉터를 만들어야 해서 코드가 점점 복잡해짐 |
| 퍼포먼스 저하 가능성                 | (미세하지만) 브라우저가 선택자 매칭하는 과정이 비효율적일 수 있음     |
| CSS 구조가 딱딱해짐                  | HTML 구조를 강하게 의존하게 되어, 유연한 변경이 힘들어짐              |

**예시 (나쁜 예)**

```
.header .menu .item .link {
  color: red;
}
```

`.item`이나 `.link` 위치 바뀌면 스타일 다 깨짐. 이걸 나중에 덮어쓰려면 더 구체적인 셀렉터를 또 만들어야 한다.

### id 셀렉터보다 클래스 기반으로 스타일링

<!--  -->

| 이유               | 설명                                                            |
| ------------------ | --------------------------------------------------------------- |
| 유연성             | 클래스는 여러 요소에 적용 가능(그룹화), id는 문서당 하나만 가능 |
| 우선순위 문제 방지 | id는 specificity가 너무 강해서 덮어쓰기 어려움                  |
| 재사용성           | 클래스는 재사용이 가능하지만 id는 불가능                        |
| 스타일 일관성      | 같은 클래스를 여러 요소에 써서 스타일을 공유할 수 있음          |

### 글로벌 스타일 오염(충돌) 방지

</br>
</br>

# 실전에서 어떤 CSS 구조를 선택하는 게 좋을까?

<!--  -->

| 방식                                               | 특징                                                          | 추천 상황                             |
| -------------------------------------------------- | ------------------------------------------------------------- | ------------------------------------- |
| BEM (Block Element Modifier)                       | 클래스 네이밍을 규칙적으로 구조화 (ex: `card__title--active`) | 중대형 프로젝트, 팀 협업              |
| OOCSS (Object Oriented CSS)                        | 스타일과 구조를 분리해 재사용성 극대화                        | 디자인 시스템 구축                    |
| SMACSS (Scalable and Modular Architecture for CSS) | 분류(기본, 레이아웃, 모듈, 상태, 테마)로 파일 구조 관리       | 대규모/장기 유지보수 프로젝트         |
| Atomic CSS / Utility-first (ex: TailwindCSS)       | 작은 유틸리티 클래스를 조합해서 스타일 구성                   | 빠른 개발, 디자인 일관성 중요할 때    |
| CSS-in-JS (styled-components, Emotion 등)          | JS 파일 안에 CSS 작성, 컴포넌트 단위 스타일                   | React, Next.js 등 컴포넌트 기반 앱    |
| Vanilla Extract / Linaria                          | 빌드 타임에 CSS 추출하는 최신 CSS-in-JS                       | 퍼포먼스, 타입 안정성까지 원하는 경우 |

</br>
</br>

# reflow, repaint, compositing은 무엇이며 일어나는 경우는?

| 개념            | 설명                                                            | 발생하는 경우                                                                  |
| --------------- | --------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| Reflow (Layout) | 요소의 크기, 위치를 다시 계산하는 과정                          | - DOM 구조 변경<br>- 요소 크기, 위치 변경<br>- 폰트 크기 변경                  |
| Repaint         | 레이아웃은 유지한 채, 요소의 스타일(색상 등)만 다시 그리는 과정 | - 배경색, 텍스트 색상 변경<br>- visibility 변경 (display는 아님)               |
| Compositing     | 레이어를 조합해 최종 화면에 그리는 과정 (GPU 사용)              | - transform, opacity, will-change 같은 속성 적용<br>- stacking context 생성 시 |

## Reflow를 많이 유발하는 코드 패턴

| 패턴                            | 설명                                                                                |
| :------------------------------ | :---------------------------------------------------------------------------------- |
| DOM을 자주 조작하는 경우        | 요소를 추가/삭제/이동할 때마다 레이아웃 계산 발생                                   |
| layout 관련 속성 자주 읽기      | offsetHeight, offsetWidth, clientTop, getComputedStyle 등을 읽으면 강제 Reflow 발생 |
| 요소 크기/위치 변경 반복        | width, height, margin, padding, border 등을 자주 변경                               |
| 연속 스타일 변경                | 요소에 여러 스타일을 하나씩 변경하면 매번 Reflow 발생                               |
| 애니메이션에서 layout 속성 사용 | top, left, width, height 기반 애니메이션은 매 프레임마다 Reflow 유발                |

### ✨ 최적화 방법

- DOM 읽기와 쓰기를 묶어서 처리 (batching)

- 가능하면 requestAnimationFrame 안에서 처리

- transform이나 opacity 기반 애니메이션 사용

## Repaint만 발생시키는 CSS 속성 리스트

| 속성                                                                  | 설명                                                 |
| :-------------------------------------------------------------------- | :--------------------------------------------------- |
| background-color                                                      | 배경색 변경                                          |
| color                                                                 | 텍스트 색상 변경                                     |
| border-color                                                          | 테두리 색상 변경                                     |
| visibility (hidden/visible)                                           | 요소 숨기기/보이기 (단, display: none은 reflow 발생) |
| box-shadow                                                            | 그림자 변경                                          |
| text-decoration                                                       | 텍스트 밑줄 등 장식 변경                             |
| outline                                                               | 포커스 테두리 변경                                   |
| opacity (변경 자체는 Compositing이지만, 투명도 조정만은 repaint 개념) |

### ✨ 주의할 점

- display: none 또는 position 변경은 reflow를 유발하지만, visibility: hidden은 repaint만 발생한다.

- opacity, transform은 대부분 Compositing만 발생해서 퍼포먼스에 더 유리하다.

<!-- ## 예시

| 작업                         | Reflow 발생 | Repaint 발생 | Compositing 발생 |
| :--------------------------- | :---------- | :----------- | :--------------- |
| width, height 변경           | ✅          | ✅           | 가능             |
| margin, padding 변경         | ✅          | ✅           | 가능             |
| color, background-color 변경 | ❌          | ✅           | ❌               |
| visibility: hidden 변경      | ❌          | ✅           | ❌               |
| transform: scale(1.2)        | ❌          | ❌           | ✅               |
| opacity 변경                 | ❌          | ❌           | ✅               |
| DOM 추가/삭제                | ✅          | ✅           | 가능             | -->

## 정리

- Reflow는 성능에 가장 큰 영향을 준다 → 최대한 줄여야 함

- Repaint는 상대적으로 가볍지만, 잦으면 성능 저하

- Compositing-only 변화(transform, opacity) 는 가장 부담이 적음 → 애니메이션에 적극 사용!

Reflow > Repaint > Compositing 순으로 비용이 크다. 레이아웃 변경을 최소화하고, GPU 친화적 속성(transform, opacity) 을 활용하면 성능이 좋아진다.

<!-- reflow 최적화 기법 (읽기/쓰기 묶기, requestAnimationFrame 활용법)?
 애니메이션 최적화 실전 팁? -->
</br>
</br>

# CSS 전처리기를 사용하면 어떤 장단점이 있는가?

장점:

- CSS의 유지보수성이 향상된다.
- 중첩 선택자를 작성하기 쉽다.
- 일관된 테마를 위한 변수사용. 여러 프로젝트에 걸쳐 테마 파일을 공유할 수 있다.
- 반복되는 CSS를 위한 Mixins 생성.
- 코드를 여러 파일로 나눈다. CSS 파일도 나눌 수 있지만, 그렇게 하기 위해서는 각 CSS 파일을 다운로드하기 위한 HTTP 요청이 필요하다.

단점:

- 전처리기를 위한 도구가 필요하다. 다시 컴파일하는 시간이 느릴 수도 있다.

<!-- # 비표준 글꼴을 사용하는 웹 디자인 컴포넌트를 어떻게 구현하는가?



font-face를 사용하고 font-weight가 다른 경우 font-family를 정의합니다. -->

</br>
</br>

# 브라우저가 CSS 선택자에 일치하는 요소를 어떻게 결정하는지 설명하시오

| 단계                                | 설명                                                                                           |
| :---------------------------------- | :--------------------------------------------------------------------------------------------- |
| 1. 우측에서 좌측으로 탐색           | 복합 선택자(combinator)에서는 항상 오른쪽(가장 구체적인)부터 시작해서 왼쪽으로 진행            |
| 2. DOM 요소 스캔                    | DOM 트리에서 오른쪽 조건을 만족하는 요소를 찾고, 부모/형제 등 관계를 따라가며 왼쪽 조건도 체크 |
| 3. 일치하면 스타일 적용 후보로 저장 | 조건을 모두 만족하면, 해당 규칙을 적용 후보로 등록                                             |

- 항상 "오른쪽 → 왼쪽" 으로 선택자 매칭한다!

- div p 선택자라면, 먼저 `<p>`를 찾고 그 부모가 `<div>`인지 확인하는 식으로 진행한다.

- 이게 훨씬 빠르기 때문에 브라우저가 이렇게 최적화되어 있다.

## 매칭 성능을 느리게 만드는 선택자들

| 문제 선택자                                   | 설명                                                              |
| :-------------------------------------------- | :---------------------------------------------------------------- |
| 너무 복잡한 선택자                            | 조합(combinator)이나 계층 구조가 깊은 것 (예: `div ul li span a`) |
| 전체 선택자(\*)                               | 모든 요소를 대상으로 하므로 매칭 범위가 크고 느려질 수 있음       |
| 후손 선택자 (띄어쓰기)                        | `div span`처럼, 모든 하위 요소를 다 뒤지기 때문에 느릴 수 있음    |
| 속성 선택자 ([attr=value])                    | `[type="text"]`처럼 속성 검사하는 건 class나 id보다 느리다        |
| 가상 클래스: `:nth-child`, `:not()`, `:has()` | 구조 계산이 필요해서 상대적으로 무거움                            |
| 중첩된 복합 선택자                            | `ul li.active span:hover` 등 너무 길고 복잡하면 비용이 크다       |

## 선택자 최적화 방법

| 최적화 방법                   | 설명                                                       |
| :---------------------------- | :--------------------------------------------------------- |
| id, class 위주로 선택         | `#id`, `.class` 사용 (가장 빠름)                           |
| 복잡한 구조 피하기            | 부모-자식-손자-증손자 구조(x) / 2~3단계 이내로 간결하게(o) |
| 구체적이고 좁은 범위에서 매칭 | `.btn-primary`처럼 명확한 범위 지정                        |
| 전체 선택자(\*) 최소화        | 꼭 필요한 곳에만 제한적으로 사용                           |
| 속성 선택자 대신 클래스 사용  | `[type="button"]` → `.btn`처럼 클래스 부여해서 최적화      |
| 동적 가상 클래스 사용 주의    | `:nth-child`, `:not()`, `:has()`는 꼭 필요한 경우만        |

## 좋은 선택자 vs 나쁜 선택자 비교

| 구분        | 예시                 | 설명                       |
| :---------- | :------------------- | :------------------------- |
| 좋은 선택자 | `.card-title`        | 클래스명 단독, 빠르고 명확 |
| 좋은 선택자 | `#main-header`       | id 단독, 매우 빠름         |
| 나쁜 선택자 | `div ul li span a`   | 계층 깊음, 매칭 비용 큼    |
| 나쁜 선택자 | `* + *`              | 전체 요소 검사, 매우 느림  |
| 나쁜 선택자 | `input[type="text"]` | 속성 검사, class가 더 빠름 |

<!-- 예를 들어, 이 선택자 p span는 먼저 모든 `<span>`요소를 찾아 그 부모의 루트까지 모두 통과하여 `<p>`요소를 찾습니다. 특정한 `<span>`의 경우 `<p>`를 찾는 즉시 `<span>`이 일치하는 것을 알고있으며, 이에 따라 매칭을 중지합니다. -->

</br>
</br>

# 반응형 디자인은 적응형 디자인과 어떻게 다른가?

| 구분        | 반응형 디자인 (Responsive Design)                               | 적응형 디자인 (Adaptive Design)                       |
| :---------- | :-------------------------------------------------------------- | :---------------------------------------------------- |
| 정의        | **하나의 유연한 레이아웃**이 화면 크기에 따라 **자동으로 변화** | 여러 개의 **고정된 레이아웃** 중 기기에 따라 **선택** |
| 방식        | 주로 `@media` 쿼리로 **비율 기반** 레이아웃 구성                | **디바이스 분기점** 기준으로 각각 별도 설계           |
| 화면 대응   | 다양한 뷰포트에 **부드럽게 대응**                               | 특정 해상도(ex. 320px, 768px 등)에만 정확하게 대응    |
| 유연성      | 매우 높음 (모든 크기에서 적응 가능)                             | 제한적 (정해진 뷰포트 외에서는 부정확 가능성)         |
| 구현 복잡도 | CSS만으로도 구현 가능 (상대 단위 사용)                          | 뷰포트마다 별도 UI 설계 필요                          |
| 예시        | 데스크톱 → 태블릿 → 모바일까지 하나의 흐름으로 축소             | 데스크톱용, 태블릿용, 모바일용 페이지가 따로 있음     |
| 유지보수    | 비교적 쉬움 (한 가지 레이아웃 관리)                             | 복잡함 (여러 레이아웃 관리 필요)                      |

</br>
</br>

# absolute 포지셔닝 대신 translate()를 사용하는 이유가 무엇인가? 또는 그 반대의 경우에 대해서는 어떻게 생각하는가? 그 이유는 무엇인가?

| 구분                   | absolute                                            | transform: translate()       |
| :--------------------- | :-------------------------------------------------- | :--------------------------- |
| 레이아웃 영향          | **문서 흐름에서 제거됨**                            | 문서 흐름에는 영향 없음      |
| 기준점                 | 가까운 `position`이 있는 조상의 `padding` 박스 기준 | 현재 위치를 기준으로 이동    |
| 트리거되는 렌더링 단계 | **Reflow + Repaint**                                | **Compositing (GPU)**        |
| 성능                   | 위치 변화 시 Layout → 느림 (CPU)                    | 위치 변화 시 빠름 (GPU 가속) |
| 주 용도                | 정적인 배치, 레이아웃 구조                          | 동적인 이동, 애니메이션      |

## translate()를 사용하는 이유

1. 애니메이션 성능이 더 좋음

- `transform: translate()`는 GPU 가속이 가능해서
  `absolute`보다 부드러운 움직임 제공 (특히 `requestAnimationFrame`과 함께 사용 시)

2. 레이아웃 안정성 유지

- `translate()`는 요소 자체는 원래 위치에 있음
  → 다른 요소에 영향을 주지 않음

3. Reflow 회피

- `absolute`를 바꾸면 브라우저가 레이아웃 전체를 다시 계산 (Reflow) 해야 함
  → `translate()`는 GPU에서 처리되므로 성능 저하가 적음

## absolute를 쓰는 경우

1. 레이아웃 상 위치 고정이 필요할 때

- 예: 툴팁, 모달, 드롭다운, 고정 배너 등
  → 조상 요소 기준(위치 지정 요소)으로 정확히 위치시켜야 할 때 유용

2. 스크롤 위치 무관한 배치가 필요할 때

- 예: 특정 영역 안에서 독립된 위치 배치

3. 시맨틱한 구조 표현

- 구조 자체에서 "이건 고정된 UI다"를 표현하고 싶을 때

## 정리

| 상황                            | 추천 방식        | 이유                 |
| ------------------------------- | ---------------- | -------------------- |
| 움직이는 UI 요소, 애니메이션    | ✅ `translate()` | 성능 + 부드러운 전환 |
| 정적인 위치 제어, 레이아웃 제어 | ✅ `absolute`    | 위치 제어에 강력     |

</br>
</br>

# CSS 애니메이션과 JS 애니메이션의 차이점

# Flex와 Grid의 차이점에 대해서 설명하시오

Flex는 주로 단일 축 방향의 레이아웃을 구성하는 데 사용되며, 주로 수평 방향으로 레이아웃을 정렬합니다. Grid는 2차원 그리드 시스템을 구성하는 데 사용되며, 수평과 수직 방향으로 모두 레이아웃을 정렬할 수 있습니다. Flex는 아이템들의 크기가 자유로워 유동적으로 변할 수 있습니다. 반면에 Grid는 아이템들의 크기를 미리 정의하여 각 셀의 크기를 일정하게 유지합니다. Flex는 유동적인 레이아웃 변화를 구성하기 적합합니다. 반면에 Grid는 미리 정의된 2차원 그리드 구조를 유지하기 때문에 레이아웃 변화가 적은 경우에 적합합니다.
