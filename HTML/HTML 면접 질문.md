- [`<!DOCTYPE>`의 의미와 역할](#doctype의-의미와-역할)
  - [1. 브라우저에 HTML 문서의 유형을 알림](#1-브라우저에-html-문서의-유형을-알림)
  - [2. 렌더링 모드 결정 (표준 모드 vs 쿼크 모드)](#2-렌더링-모드-결정-표준-모드-vs-쿼크-모드)
  - [왜 이런 시스템이 생겼을까?](#왜-이런-시스템이-생겼을까)
- [여러 언어로 되어 있는 콘텐츠의 페이지는 어떻게 제공할까?](#여러-언어로-되어-있는-콘텐츠의-페이지는-어떻게-제공할까)
  - [1. 문서 전체의 기본 언어 설정](#1-문서-전체의-기본-언어-설정)
  - [2. 문서 내 일부 콘텐츠가 다른 언어일 때](#2-문서-내-일부-콘텐츠가-다른-언어일-때)
- [다국어 사이트를 디자인하거나 개발할 때 주의해야할 사항은 무엇인가?](#다국어-사이트를-디자인하거나-개발할-때-주의해야할-사항은-무엇인가)
  - [국제화 (internationalization, I18N)?](#국제화-internationalization-i18n)
- [`data-*` 속성을 사용하는 이유?](#data--속성을-사용하는-이유)
  - [장점](#장점)
  - [단점](#단점)
  - [언제 사용하면 좋을까?](#언제-사용하면-좋을까)
  - [`data-*` 쓰지 말아야 할 경우](#data--쓰지-말아야-할-경우)
- [`cookie`, `sessionStorage`, `localStorage`의 차이점](#cookie-sessionstorage-localstorage의-차이점)
- [`<script>`, `<script async>`, `<script defer>`의 차이점](#script-script-async-script-defer의-차이점)
  - [기본 `<script>` 동작](#기본-script-동작)
  - [`async`](#async)
  - [`defer`](#defer)
  - [정리](#정리)
  - [언제 뭘 써야 할까?](#언제-뭘-써야-할까)
- [프로그레시브 렌더링이란 무엇인가?](#프로그레시브-렌더링이란-무엇인가)
  - [필요성](#필요성)
  - [어떤 방식들이 있는가?](#어떤-방식들이-있는가)
- [왜 일반적으로 CSS `<link>` 태그를 `<head></head>` 태그 사이에 위치시키고, JS `<script>` 태그를 `</body>` 직전에 위치시키는 것이 좋은 방법인가? 다른 예외적인 상황은?](#왜-일반적으로-css-link-태그를-headhead-태그-사이에-위치시키고-js-script-태그를-body-직전에-위치시키는-것이-좋은-방법인가-다른-예외적인-상황은)
  - [`<head>` 안에 CSS `<link>`를 넣는 이유](#head-안에-css-link를-넣는-이유)
  - [`</body>` 직전에 `<script>`를 넣는 이유](#body-직전에-script를-넣는-이유)
  - [예외적인 상황들](#예외적인-상황들)

</br>
</br>

# `<!DOCTYPE>`의 의미와 역할

## 1. 브라우저에 HTML 문서의 유형을 알림

브라우저는 HTML 문서를 해석할 때, 어떤 규칙(문법)을 따를지 결정해야 한다. 이때 사용하는게 `<!DOCTYPE>`으로 문서의 버전을 정의하기 위해 사용하는 선언문(DTD / Document Type Definition)이다.

DOCTYPE은 HTML 문서 최상단에 위치하며 HTML5 표준에 대한 DOCTYPE 선언은 `<!DOCTYPE html>` 이다.

## 2. 렌더링 모드 결정 (표준 모드 vs 쿼크 모드)

브라우저는 `<!DOCTYPE>` 선언 유무와 형태에 따라 다음 중 하나의 렌더링 모드를 선택한다.

- 표준 모드 (Standards Mode): W3C 표준에 맞춰 정확하게 렌더링
- 쿼크 모드 (Quirks Mode): 옛날 브라우저와의 호환성을 위한 비표준 방식으로 렌더링
- 부분 표준 모드 (Almost Standards Mode, limited-quirks): 대부분 표준대로 동작하지만, `<img>` 등의 처리에서 일부 비표준 허용

`<!DOCTYPE>`을 제대로 선언하지 않으면, 쿼크 모드로 동작해서 레이아웃이 깨지는 등 예기치 못한 문제들이 발생할 수 있다.

## 왜 이런 시스템이 생겼을까?

초창기 웹은 표준이 명확하지 않았고, 각 브라우저마다 HTML/CSS 해석 방식이 달랐다.

이후 W3C가 표준을 만들기 시작했지만, 이미 비표준 방식에 맞춰 제작된 옛날 웹 사이트들이 너무 많았기 때문에 DOCTYPE을 보고 그에 맞게 해석하도록 하게 된 것.

</br>
</br>

# 여러 언어로 되어 있는 콘텐츠의 페이지는 어떻게 제공할까?

## 1. 문서 전체의 기본 언어 설정

HTML 문서 최상단의 `<html>` 태그에 `lang` 속성을 지정해준다. 이 설정은 스크린 리더, 번역기, 검색 엔진 모두에게 중요하다.

```
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>다국어 예제</title>
</head>
<body>
  ...
</body>
</html>
```

## 2. 문서 내 일부 콘텐츠가 다른 언어일 때

`lang` 속성을 사용해 언어를 명시적으로 지정해주는 것이 필요하다. 또한 `dir` 속성을 사용해 텍스트를 읽고 쓰는 방향(direction)을 지정 해줘야 한다. 이렇게 해야 스크린 리더나 번역기 등이 언어 구분을 정확히 인식할 수 있다(접근성(A11y) 측면에서 매우 중요).

```
<p>이 웹사이트는 <span lang="en">multilingual support</span>를 제공합니다.</p>

<p>こんにちは、<span lang="ja">ようこそ！</span></p>

<!-- 오른쪽에서 배치되어 왼쪽으로 읽고 쓰기 -->
<p lang="ar" dir="rtl">هذا نص من اليمين إلى اليسا</p> <!-- 아랍어 -->
<p lang="he" dir="rtl">זהו טקסט שנכתב מימין לשמאל.</p> <!-- 히브리어 -->
```

</br>
</br>

**[`lang` 속성에 대하여]**

https://codingeverybody.kr/html-lang-%EC%86%8D%EC%84%B1-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%9D%B4%ED%95%B4%EC%99%80-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95/

</br>
</br>

# 다국어 사이트를 디자인하거나 개발할 때 주의해야할 사항은 무엇인가?

- <h3> html 태그에 적절한 lang 속성 값을 사용한다</h3>

- <h3>사용자를 그들의 모국어로 안내한다</h3>

  사용자가 번거롭지 않도록 쉽게 국가/언어를 변경할 수 있도록 한다. 혹은 브라우저 언어 감지 후 자동 리디렉션하거나(너무 강제적이면 UX가 나빠질 수 있으니 주의!) 서버에서 `Accept-Language` 헤더를 감지해서 초기 언어를 설정한다.

  ```
  const userLang = navigator.language || navigator.userLanguage;
  if (userLang.startsWith('en')) {
    window.location.href = '/en/';
  }
  ```

  사용자가 선택한 언어는 localStorage 혹은 cookie에 저장해서 재방문 시 유지한다.

- <h3>국제화(i18n) 라이브러리 선택</h3>

  대표 라이브러리: `react-i18next`, `next-intl`, `formatjs`, `vue-i18n` 등

  기능 체크: 동적 언어 변경 가능 여부, 복수형 처리 지원, 날짜/숫자/통화 포맷 지원, lazy loading 방식 지원 (성능 ↑)

- <h3>텍스트 길이 변화 고려</h3>

  언어에 따라 텍스트 길이가 크게 달라질 수 있다.

  - ex) 영어 "Login" → 독일어 "Anmelden", 프랑스어 "Se connecter"

  이때 레이아웃이 깨지지 않도록 `flex`, `min-width`, `max-width`, `text-wrap` 등으로 유연하게 설계하도록 한다. 버튼이나 카드 컴포넌트는 특히 주의!

- <h3>언어 방향성 처리 (LTR ↔ RTL)</h3>

  아랍어, 히브리어 등은 RTL(Right to Left) 방향이므로 CSS에서 다음과 같이 처리하거나 요소 내에 `dir` 속성을 명시해준다.

  ```
  html[dir="rtl"] {
    direction: rtl;
    text-align: right;
  }
  ```

- <h3>로컬라이징(Localization)된 포맷 적용</h3>

  날짜, 숫자, 통화 포맷은 국가마다 다름

  - ex) 미국의 "May 31, 2012" vs. 유럽의 "31 May 2012".

  `Intl.DateTimeFormat`, `Intl.NumberFormat` 사용 권장.

- <h3>텍스트를 포함한 이미지를 지양</h3>

  이미지에 텍스트를 번역하려면, 텍스트 문자열에 각 언어에 대해 만들어진 별도 이미지가 필요하므로 관리하기 어려움.

- <h3>이미지, 아이콘, 색상 사용 주의</h3>

  문화적 차이를 고려해서 이미지/아이콘/색상도 현지화 필요할 수 있다.

  - ex) 일부 국가에서는 손 모양 이모지 의미가 다름.

- <h3>다국어 페이지 별도의 URL 사용하여 SEO 최적화</h3>

  검색 엔진이 각 언어 페이지를 인식할 수 있도록 언어별 경로를 사용하는 것이 좋다다.

  또한 `<link rel="alternate" hreflang="ko" href="https://example.com/ko" />` 태그를 설정하여 검색 엔진에게 언어만 다른 페이지가 중복 콘텐츠가 아님을 알려주어 검색 순위 하락을 막을 수 있고 사용자 언어에 맞는 적절한 페이지를 검색 결과에 노출되게 할 수 있다다.

  ```
  <link rel="alternate" hreflang="en" href="https://example.com/en/" />
  <link rel="alternate" hreflang="en-us" href="https://example.com/en-us/" />
  <link rel="alternate" hreflang="en-gb" href="https://example.com/en-gb/" />
  <link rel="alternate" hreflang="ko" href="https://example.com/ko/" />
  <link rel="alternate" hreflang="x-default" href="https://example.com/" />  // x-default: 언어 선택 페이지나 기본 페이지에 사용
  ```

  `Next.js` 쓸 경우 `i18n` 설정으로 처리 가능

<!-- ✅ 9. 테스트와 품질 관리
  언어별 QA 필요: 텍스트 오버플로우, 잘못된 번역, 방향성 문제 등

자동화 테스트에서도 다국어 렌더링 확인할 수 있도록 설계

✅ 10. 성능 고려
언어 파일은 번역 수가 많으면 크기가 큼 → 코드 스플리팅 및 언어별 Lazy Loading 적용

Next.js의 경우 getStaticProps를 활용해 언어별 페이지를 정적 생성하면 속도 ↑ -->

## 국제화 (internationalization, I18N)?

```
국제화 (i18n ("internationalization" 부터 유래, 20자로 이루어진 단어))는 하나의 애플리케이션이 여러 국가, 언어, 지역에서 사용될 수 있도록 만드는 준비 과정을 말한다.
예를 들어 웹사이트를 처음부터 영어, 한국어, 일본어 등 다국어로 만들 수 있도록 기반 구조를 잡는 것이 국제화다.
참고로 실제로 번역하고 콘텐츠를 적용하는 것은 지역화(localization, l10n)라고 한다.
```

  </br>
  </br>

# `data-*` 속성을 사용하는 이유?

HTML 요소에 사용자 정의 데이터를 저장할 수 있게 해주는 기능이다. 즉, `data-`로 시작하는 속성은 **사용자 정의 데이터 속성**이다.

다음과 같이 `data-user-id`, `data-role` 같은 식으로 원하는 키 이름을 만들어 데이터를 HTML 요소에 직접 저장할 수 있다.

JS에선 `data-*` 어트리뷰트는 카멜 케이스로 변환된다(`data-user-id` -> `dataset.userId`).

```
<div id="user" data-user-id="1234" data-role="admin">홍길동</div>
```

## 장점

- **HTML에 맞지 않는 데이터 저장 가능**

  HTML에 직접 표현할 수 없는 추가적인 메타데이터를 저장할 수 있다.

- **JS와의 연동이 쉬움**

  JavaScript에서 `HTMLElement.dataset` 프로퍼티를 통해 쉽게 접근 가능함(`DOMStringMap` 객체 반환).

- **클래스나 id에 비해 의미가 명확함**

  데이터를 담기 위한 속성이므로, 의미가 명확하다.

- **데이터 바인딩/추적용으로 편리함**

  동적 UI에서 특정 정보를 DOM에 붙여두면, 나중에 쉽게 추적 가능.

## 단점

- **큰 데이터 저장에는 부적합**

  HTML에 모든 데이터를 넣는 건 성능/가독성에 안 좋음. JSON 문자열 같은 큰 데이터는 비효율적.

- **보안 이슈 발생 가능성**

  누구나 페이지 소스에서 볼 수 있기 때문에, **민감한 정보(토큰, 비밀번호 등)**를 저장하면 안된다.

- **복잡한 상태관리에는 부족**

  단순 값 저장엔 좋지만, 앱 전역 상태 관리에는 한계가 있음.

## 언제 사용하면 좋을까?

✔️ 1. 자바스크립트용 간단한 커스텀 데이터가 필요할 때
HTML에 있는 요소에 어떤 정보를 "숨겨서" 전달하고 싶을 때 좋다.

✔️ 2. DOM 요소마다 다른 설정을 저장할 때
예: 슬라이드에 각기 다른 속도/효과 설정을 줄 때

✔️ 3. CSS로는 불가능한 상태 정보가 필요할 때
예: 토글 버튼의 현재 상태를 data-state로 저장

✔️ 4. 서버로부터 받아온 데이터 임시 저장 시
JS로 쓰고 지우고, 동적으로 접근할 임시 데이터로 사용하기 좋음.

## `data-*` 쓰지 말아야 할 경우

| 상황                                 | 이유                                        | 대안                                     |
| ------------------------------------ | ------------------------------------------- | ---------------------------------------- |
| 이미 의미 있는 HTML 속성이 있는 경우 | 중복되거나 불필요한 정보가 됨               | `href`, `src`, `value` 등 기본 속성 사용 |
| 중요하거나 민감한 정보 저장          | 사용자에게 노출 가능 (개발자 도구에서 보임) | JS 내 변수로 처리하거나 서버에서 관리    |
| 뷰 라이브러리 상태 관리 대체 용도    | 상태 분리 원칙에 어긋남                     | React/Vue의 `state`, `props` 등 활용     |

</br>
</br>

<!-- # HTML5를 개방형 웹 플랫폼으로 간주할 때, HTML5의 구성 요소는 무엇인가? -->
<!--
</br>
</br> -->

# `cookie`, `sessionStorage`, `localStorage`의 차이점

| 구분             | 쿠키 (Cookie)                                 | sessionStorage                         | localStorage                  |
| ---------------- | --------------------------------------------- | -------------------------------------- | ----------------------------- |
| 저장 위치        | 브라우저와 서버(Set-cookie) 모두              | 브라우저 (클라이언트)                  | 브라우저 (클라이언트)         |
| 데이터 용량 제한 | 약 4KB                                        | 약 5~10MB                              | 약 5~10MB                     |
| 자동 서버 전송   | ✅ 매 요청 시 서버로 자동 전송                | ❌ 서버로 전송되지 않음                | ❌ 서버로 전송되지 않음       |
| 유효 기간        | 설정 가능 (만료 시간 설정)                    | 탭을 닫을 때 삭제                      | 명시적 삭제 전까지 유지       |
| 접근 가능 위치   | 브라우저, 서버 (HTTP 헤더 통해 접근)          | 브라우저 내 현재 탭                    | 브라우저 전역(특정 origin)    |
| 보안 설정 가능   | ✅ `Secure`, `HttpOnly`, `SameSite` 설정 가능 | ❌ 설정 불가                           | ❌ 설정 불가                  |
| 사용 예시        | 로그인 정보, 인증 토큰, 사용자 식별 등        | 페이지 간 데이터 공유 (단, 같은 탭 내) | 장기적인 사용자 설정, 캐시 등 |

추가 내용은 `../JS/Web Storage.md` 참고

</br>
</br>

# `<script>`, `<script async>`, `<script defer>`의 차이점

## 기본 `<script>` 동작

- HTML을 파싱하다가 script 태그를 만나면 HTML 파싱을 중단하고(블록킹),

- JS 파일을 다운로드하고,

- 다운로드가 끝나면 즉시 실행한 다음,

- 다시 HTML 파싱을 재개함 -> 결과적으로 페이지 렌더링이 느려질 수 있다.

## `async`

- JS를 병렬로 다운로드

- 다운로드가 끝나면 HTML 파싱을 중단하고 즉시 실행

- ✅ 빠르게 실행됨

- ❌ 하지만 실행 순서가 보장되지 않아서, 다른 스크립트나 DOM이 준비되기 전에 실행되면 오류 발생 가능성 있음

📍 사용 예시:

광고 스크립트, 트래킹 코드, 소셜 버튼 등
다른 코드와 독립적으로 작동하는 외부 스크립트에 적합

## `defer`

- JS를 병렬로 다운로드

- HTML 파싱이 완전히 끝난 후 실행

- ✅ 여러 defer 스크립트가 있을 경우, 작성 순서대로 실행됨

- ✅ DOM이 다 준비된 뒤 실행되므로 안정적

📍 사용 예시:

일반적인 애플리케이션 코드, DOM 조작이 필요한 JS 파일

</br>

## 정리

| 속성    | HTML 파싱 중 다운로드 | 실행 시점                                  | 실행 순서 보장           |
| ------- | --------------------- | ------------------------------------------ | ------------------------ |
| 없음    | ❌ 파싱 중단됨        | 다운로드 직후                              | ❌ 없음                  |
| `async` | ✅ 병렬 다운로드      | 다운로드 완료 즉시 실행                    | ❌ 없음 (순서 랜덤)      |
| `defer` | ✅ 병렬 다운로드      | HTML 파싱 완료 후, `DOMContentLoaded` 직전 | ✅ 있음 (작성 순서 보장) |

</br>

## 언제 뭘 써야 할까?

| 상황                                                   | 사용 속성                              | 이유                                               |
| ------------------------------------------------------ | -------------------------------------- | -------------------------------------------------- |
| 📦 분석, 광고, 소셜 위젯 등 **독립적인 외부 스크립트** | `async`                                | 실행 순서 상관없고 빠르게 로드되는 것이 중요함     |
| 🧠 **메인 자바스크립트 파일** (DOM 조작 포함)          | `defer`                                | HTML 파싱 완료 후 DOM이 구성된 뒤 실행됨           |
| 🔄 **여러 스크립트 간 실행 순서 중요**                 | `defer`                                | 작성된 순서대로 실행되므로 의존성 문제 없음        |
| 🧪 **HTML보다 먼저 실행돼야 하는 스크립트**            | 아무 속성 없이 `<script>`를 `<head>`에 | polyfill, 설정값 지정 등은 HTML 전에 실행되어야 함 |

참고로 `src` 속성이 없는 스크립트 태그는 `async` 와 `defer` 속성이 무시된다.

</br>
</br>

# 프로그레시브 렌더링이란 무엇인가?

프로그레시브 렌더링(Progressive Rendering)은 웹 페이지를 한 번에 전부 다 불러온 다음에 보여주는 게 아니라, **불러올 수 있는 부분부터 순차적으로 화면에 렌더링해주는 기술 또는 전략**을 말한다.

```
Progressive Rendering은 Progressive Web App(PWA)와는 다르다!
PWA는 오프라인 지원, 캐시, 푸시 알림 등을 포함한 전체 앱 경험을 말하고,
Progressive Rendering은 화면에 "보여주는 방식"에 관한 전략이다.
```

## 필요성

웹페이지가 점점 무거워지고, 이미지·스크립트·서버 응답 등이 많아지면서 페이지 로딩 시간이 길어졌다. 그동안 사용자에게 아무것도 안 보이면 좋지 못한 사용자 경험을 겪게 될 것.

그래서 등장한 게 프로그레시브 렌더링이다. 렌더링 가능한 부분부터 조금씩 빠르게 보여주는 방식으로, 사용자에게 더 **빠른 응답감**을 주고, 지루함이나 **이탈률을 줄이는 데 도움**이 된다.

## 어떤 방식들이 있는가?

- ### HTML 스트리밍

  서버에서 HTML을 한 덩어리로 다 전송하지 않고, 조각조각(스트리밍) 보내면서 클라이언트는 받은 만큼 렌더링을 시작함. SSR(Server Side Rendering)에서 많이 사용된다.

  ex) React의 Streaming SSR이나 Next.js 13+의 app/ 디렉토리 방식.
  <!-- ? -->

- ### 이미지 지연 로딩 (Lazy Loading)

  화면에 보이지 않는 이미지는 나중에 스크롤될 때 로딩함.

  ex) `<img loading="lazy">`

- ### Skeleton UI (스켈레톤 화면)

  콘텐츠가 로딩되기 전까지는 회색 박스, 로딩 애니메이션 등으로 자리만 잡아두고 사용자는 페이지가 로딩 중이라는 걸 시각적으로 인식할 수 있다.

- ### Critical CSS / Above-the-fold 렌더링

  **화면에 처음 보이는 영역(above-the-fold, 스크롤 없이 바로 보이는 영역)** 만 먼저 렌더링하고, 나머지 스타일은 나중에 불러옴. 사용자 눈에는 빠르게 페이지가 뜨는 것처럼 느껴진다.

  - <h3>Critical CSS?</h3>

    ```
    크리티컬 CSS란, 웹 페이지의 렌더링을 최적화하기 위해 사용자가 먼저 보게 되는 화면(스크롤 없이 보이는 영역)에 필요한 CSS 스타일만 추출하여 HTML 문서의 <head> 영역에 인라인으로 삽입하는 것을 말합니다. 즉, 브라우저가 CSS 파일을 다운로드하기 전에 필요한 스타일을 적용하여 웹 페이지가 빠르게 로딩되도록 하는 방법입니다.
    ```

- ### 비동기 스크립트 로딩 (`async`, `defer`)

  `<script>` 태그에 `async` 또는 `defer` 속성을 붙여서 HTML이 멈추지 않고 동시에 다른 리소스를 로딩할 수 있게 함.

<!-- 특정 프레임워크(React, Next.js 등)에서 프로그레시브 렌더링 구현 방법? -->
</br>
</br>

# 왜 일반적으로 CSS `<link>` 태그를 `<head></head>` 태그 사이에 위치시키고, JS `<script>` 태그를 `</body>` 직전에 위치시키는 것이 좋은 방법인가? 다른 예외적인 상황은?

## `<head>` 안에 CSS `<link>`를 넣는 이유

<h3>이유 1: 스타일이 먼저 적용되어야 화면이 깔끔하게 보임</h3>

브라우저는 HTML을 위에서 아래로 읽으면서 렌더링한다. 그러므로 스타일을 먼저 읽고 적용해야 화면이 깨지거나 스타일이 없는 내용이 보여지는 FOUC (Flash of Unstyled Content)현상을 방지할 수 있다.

<h3>이유 2: 렌더링 차단 요소 (Render Blocking)</h3>

CSS는 기본적으로 렌더링을 **차단(blocking)**함(다운로드 시) 즉, 브라우저는 CSS를 다 받아야 화면을 그릴 수 있다. 따라서 최대한 빨리 가져오고 적용해야 렌더링이 지연되지 않는다.

👉 결론: `<head>`에 CSS `<link>`를 넣는 것이 화면을 빠르고 자연스럽게 보여주는 데 가장 좋다.

<!-- `<link>`를 `<head>` 안에 넣는 것은 최적화된 웹사이트를 구출할 때 적절한 명세의 일부입니다. 페이지가 처음로드되면 HTML과 CSS가 동시에 파싱됩니다. HTML은 DOM(Document Object Model)을 만들고 CSS는 CSSOM (CSS Object Model)을 만듭니다. 두 가지 모두 웹사이트에서 시각적인 부분을 만드는데 필요하므로, 빠른 "first meaningful paint"를 가능하게 합니다. 이 점진적 렌더링은 사이트의 성능 점수에서 측정되는 사이트 최적화의 범주입니다. 문서 최하단에 스타일시트를 두는 것은 많은 브라우저에서 점진적 렌더링을 금지하게 되는 것입니다. 몇몇 브라우저는 스타일이 변경되면 페이지의 요소를 다시 그리는 것을 피하기 위해 렌더링을 차단합니다. 그렇게되면 사용자는 빈 하얀 페이지를 보게됩니다.

그 외에도 상단에 배치하면 페이지가 점진적으로 렌더링되기 때문에 UX가 향상됩니다. 또한 스타일이 없는 내용이 잠깐 보이는 것을 방지합니다. 다른 경우에는 스타일되지 않은 내용이 깜빡일 수 있습니다(flashes of unstyled content: FOUC). -->

## `</body>` 직전에 `<script>`를 넣는 이유

<h3>📌 이유 1: 렌더링 차단 없이 HTML 먼저 로드 가능</h3>

JS도 기본적으로 렌더링 차단 요소이다(async, defer 아닌 경우). 따라서 `<head>`에 넣으면 스크립트가 실행될 때까지 HTML 파싱이 멈추게 된다. 반면, `<body>` 맨 마지막에 넣으면 HTML 다 파싱한 후에 실행된다.

즉, DOM을 다 만들어 놓고 나서 JS 실행되기 때문에 화면 출력에 안정적이다.

<h3>📌 이유 2: DOM 요소를 조작할 수 있음</h3>

JS가 DOM 요소를 다루려면 요소가 먼저 존재해야 하는데 JS가 먼저 실행되면 document.getElementById(...) 같은 코드가 에러 날 수 있다.

👉 결론: 일반적인 JS는 `</body>` 직전에 넣는 것이 안전하고 성능에도 유리

<!-- `<script>`는 다운로드되고 실행되는 동안 HTML 파싱을 차단합니다. 스크립트를 맨 아래에 두면 HTML을 먼저 파싱하여 사용자에게 표시할 수 있습니다.

스크립트에 document.write()가 있을 때는 `<script>`를 아래쪽에 두는 것이 예외적일 수 있습니다만, 요즘은 document.write()를 사용하지 않는 것이 좋습니다. 또한, `<script>`를 맨 아래에 두면, 브라우저가 전체 문서가 파싱될 때까지 스크립트 다운로드를 시작할 수 없다는 것을 의미합니다. 이렇게하면 DOM 요소를 조작해야하는 코드가 오류를 발생시키지 않고 전체 스크립트를 중지시키지 않습니다. `<head>`에 `<script>`를 넣어야하는 경우, defer 속성을 사용하세요. HTML을 파싱한 후에 스크립트를 다운로드하고 실행하는 것과 같은 효과가 있습니다. -->

## 예외적인 상황들

🔹 1. `<script>`를 `<head>`에 넣는 경우

외부 라이브러리를 꼭 먼저 로딩해야 할 때

단, 이때는 defer 또는 async 속성을 꼭 붙임

✅ defer 사용

```
<script src="/main.js" defer></script>
```

HTML 파싱을 막지 않음

DOM 파싱이 끝난 뒤 실행됨 (순서 보장됨)

✅ async 사용

```
<script src="/main.js" async></script>
```

HTML 파싱을 막지 않음

다운로드 완료 즉시 실행 (실행 순서는 보장 안됨)

주로 광고, 분석 스크립트 등 독립적인 JS에 사용

🔹 2. CSS를 `<head>`가 아닌 다른 곳에 넣는 경우

**SPA (Single Page Application)** 에서 CSS-in-JS를 사용할 때

ex: Styled-components, Emotion → JS 실행 후 스타일 주입

JS에서 동적으로 style 태그 삽입할 때

🔹 3. Critical CSS 인라인 삽입

렌더링 성능 극대화를 위해 `<style>`을 `<head>`에 직접 넣음

```
<style>
  body { margin: 0; font-family: sans-serif; }
</style>
```

주로 First Paint 성능 향상을 위해 적용됨
