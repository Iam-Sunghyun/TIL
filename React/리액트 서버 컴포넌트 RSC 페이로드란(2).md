- [서버 컴포넌트와 클라이언트 컴포넌트는 따로 전송되는가?](#서버-컴포넌트와-클라이언트-컴포넌트는-따로-전송되는가)
- [최초 페이지 요청 시 서버 컴포넌트와 클라이언트 컴포넌트 전송 과정 요약](#최초-페이지-요청-시-서버-컴포넌트와-클라이언트-컴포넌트-전송-과정-요약)
    - [1. 사용자가 페이지를 요청하면](#1-사용자가-페이지를-요청하면)
    - [2. 서버가 클라이언트로 RSC 페이로드를 전송](#2-서버가-클라이언트로-rsc-페이로드를-전송)
    - [3. 클라이언트에서 React 클라이언트 런타임이 RSC 페이로드를 해석하고 UI를 구성](#3-클라이언트에서-react-클라이언트-런타임이-rsc-페이로드를-해석하고-ui를-구성)
- [🛠 예제: 서버 컴포넌트 + 클라이언트 컴포넌트의 전송 흐름](#-예제-서버-컴포넌트--클라이언트-컴포넌트의-전송-흐름)
    - [1. 서버에서 렌더링되는 페이지 (app/page.tsx)](#1-서버에서-렌더링되는-페이지-apppagetsx)
    - [2. 서버에서 생성되는 RSC 페이로드 (JSON-like 데이터)](#2-서버에서-생성되는-rsc-페이로드-json-like-데이터)
    - [3. 클라이언트에서 최종 UI 렌더링](#3-클라이언트에서-최종-ui-렌더링)
- [정리](#정리)

# 서버 컴포넌트와 클라이언트 컴포넌트는 따로 전송되는가?

서버 컴포넌트(RSC)는 서버에서 렌더링된 후, 클라이언트 컴포넌트와 따로 전송된다.

<!-- ↑ 헷갈 -->

서버에서 서버 컴포넌트를 먼저 렌더링하여 RSC 페이로드(JSON-like 데이터)를 생성한 후, 이 데이터가 클라이언트로 스트리밍되면서 클라이언트 컴포넌트와 결합하여 React 트리를 구성하게 된다.

# 최초 페이지 요청 시 서버 컴포넌트와 클라이언트 컴포넌트 전송 과정 요약

### 1. 사용자가 페이지를 요청하면

- Next.js (예: app/page.tsx)는 서버 컴포넌트와 클라이언트 컴포넌트를 포함하는 React 트리를 생성.
- 서버 컴포넌트는 서버에서 실행되고, HTML이 아니라 JSON-like RSC 페이로드로 변환됨. 이떄 클라이언트 컴포넌트 자리는 따로 표시만 된다.

### 2. 서버가 클라이언트로 RSC 페이로드를 전송

- 서버 컴포넌트는 HTML이 아니라 RSC 페이로드(JSON-like) 데이터로 전송됨.
- RSC 페이로드는 스트리밍 방식으로 전달될 수 있어서, 클라이언트가 받은 데이터를 즉시 렌더링하면서, 남은 데이터를 계속 받아올 수 있다.
- 클라이언트 컴포넌트는 JavaScript 번들로 제공되며, 클라이언트에서 실행된다.

### 3. 클라이언트에서 React 클라이언트 런타임이 RSC 페이로드를 해석하고 UI를 구성

- RSC 페이로드는 클라이언트에서 React 클라이언트 런타임이 해석하고, 그 후 클라이언트 컴포넌트가 JavaScript 번들로 로드되고 실행되면서 전체 React 트리가 완성된다.

# 🛠 예제: 서버 컴포넌트 + 클라이언트 컴포넌트의 전송 흐름

### 1. 서버에서 렌더링되는 페이지 (app/page.tsx)

```
import ServerComponent from "@/components/ServerComponent";
import ClientComponent from "@/components/ClientComponent";

export default function Page() {
  return (
    <div>
      <ServerComponent />
      <ClientComponent />
    </div>
  );
}
```

➡️ ServerComponent는 서버에서 실행.
➡️ ClientComponent는 클라이언트에서 실행.

### 2. 서버에서 생성되는 RSC 페이로드 (JSON-like 데이터)

서버가 ServerComponent를 렌더링한 결과를 클라이언트로 전송할 때, 아래처럼 JSON-like 데이터가 전송된다.

```
[
  {
    "type": "div",
      "props": {
        "children": [
        {
          "type": "h1",
          "props": { "children": "서버에서 가져온 데이터" }
        },
        {
          "$type": "ClientComponent",
          "$id": "some-unique-id"
        }
      ]
    }
  }
]
```

➡️ 서버 컴포넌트 부분은 이미 서버에서 처리된 상태로 전송되며 **클라이언트 컴포넌트는 실제 JavaScript가 실행되어야 하므로, 자리만 표시된다.**

### 3. 클라이언트에서 최종 UI 렌더링

클라이언트는 서버 컴포넌트의 RSC 페이로드를 해석한 후, 클라이언트 컴포넌트를 포함하여 최종 UI를 렌더링된다.

```
<div>
  <h1>서버에서 가져온 데이터</h1>  // 서버 컴포넌트 결과
  <button>클릭 0</button>          // 클라이언트 컴포넌트 결과
</div>
```

✅ 서버 컴포넌트는 서버에서 실행되었고, 클라이언트에서 별도로 실행되지 않음.

✅ 클라이언트 컴포넌트는 클라이언트에서 실행되어 인터랙션을 담당.

# 정리

- ✅ 서버 컴포넌트는 서버에서 실행되고, **RSC 페이로드(JSON-like 데이터)로 변환되어 클라이언트로 전송된다.**
- ✅ **클라이언트 컴포넌트는 JavaScript 번들로 제공되며, 클라이언트에서 실행된다.**
- ✅ 클라이언트는 RSC 페이로드를 해석하여 서버 컴포넌트와 클라이언트 컴포넌트를 함께 React 트리로 구성한다.
- ✅ 결과적으로 서버 컴포넌트와 클라이언트 컴포넌트가 하나의 React 트리를 이루며, UI가 렌더링된다.

즉, "서버 컴포넌트와 클라이언트 컴포넌트가 완전히 따로 전송된다"기보다는, 서버에서 JSON-like RSC 페이로드를 전송하고 클라이언트에서 이를 해석해 하나의 React 트리를 형성한다고 이해하면 된다.
