- [RSC 페이로드란?](#rsc-페이로드란)
  - [RSC 페이로드의 예시](#rsc-페이로드의-예시)
  - [Json-like 데이터란?](#json-like-데이터란)
- [클라이언트로 가는 데이터 흐름](#클라이언트로-가는-데이터-흐름)
  - [1. 서버에서 React Server Component를 실행](#1-서버에서-react-server-component를-실행)
  - [2. 서버가 클라이언트로 RSC 페이로드 및 데이터 전송](#2-서버가-클라이언트로-rsc-페이로드-및-데이터-전송)
  - [3. 클라이언트에서 해석](#3-클라이언트에서-해석)
- [클라이언트 컴포넌트에 서버 컴포넌트를 불러올 수 없는 이유?](#클라이언트-컴포넌트에-서버-컴포넌트를-불러올-수-없는-이유)
  - [1. 실행 환경이 다르다](#1-실행-환경이-다르다)
  - [2. 번들링 과정에서 충돌](#2-번들링-과정에서-충돌)
  - [3. 데이터 흐름 제약(단방향)](#3-데이터-흐름-제약단방향)
- [서버 컴포넌트에서 클라이언트 컴포넌트로 일반 함수를 전달할 수 없는 이유](#서버-컴포넌트에서-클라이언트-컴포넌트로-일반-함수를-전달할-수-없는-이유)
  - [직렬화 문제](#직렬화-문제)
  - [예외](#예외)

# RSC 페이로드란?

**RSC 페이로드(RSC Payload)** 는 React Server Component가 서버에서 렌더링된 후, 클라이언트로 전달되는 React 컴포넌트 트리를 직렬화한 데이터를 말한다.

이 페이로드는 일반적인 HTML이 아니라, **JSON-like** 형식으로 되어 있으며, 브라우저에서 직접 실행되지 않고 React의 클라이언트 런타임에 의해 해석된다.

또한 자바스크립트 번들에 포함되는 게 아닌 별도의 네트워크 요청을 통해 클라이언트 측으로 전송된다.

## RSC 페이로드의 예시

```
// ServerComponent.tsx (RSC)
import ClientButton from "./ClientButton";

export default async function ServerComponent() {
  const data = await fetch("https://jsonplaceholder.typicode.com/todos/1").then(r => r.json());

  return (
    <section>
      <h1>Todo: {data.title}</h1>
      <ul>
        <li>ID: {data.id}</li>
        <li>Completed: {String(data.completed)}</li>
      </ul>
      <ClientButton label="Click me!" />
    </section>
  );
}
---------------------------
// ClientButton.tsx (Client Component)
"use client";

export default function ClientButton({ label }: { label: string }) {
  return <button onClick={() => alert("clicked!")}>{label}</button>;
}
---------------------------

---------------------------
// RSC 페이로드(json-like 데이터)
J0: ["$","section",null,{
  "children":[
    ["$","h1",null,{"children":"Todo: delectus aut autem"}],
    "$L0",
    "$L3"
  ]
}]
---------------------------
L0: ["$","ul",null,{
  "children":[
    "$L1",
    "$L2"
  ]
}]
---------------------------
L1: ["$","li",null,{"children":"ID: 1"}]
---------------------------
L2: ["$","li",null,{"children":"Completed: false"}]
---------------------------
L3: ["$","ClientButton","$L4",{"label":"Click me!"}]
---------------------------
L4: "$$moduleReference(ClientButton)"
----------------------------------

----------------------------------
// 실제 Flight wire format (raw 프로토콜)
1:["$","section",null,{"children":[["$","h1",null,{"children":"Todo: delectus aut autem"}],"$2","$5"]}]
2:["$","ul",null,{"children":["$3","$4"]}]
3:["$","li",null,{"children":"ID: 1"}]
4:["$","li",null,{"children":"Completed: false"}]
5:["$","ClientButton","$6",{"label":"Click me!"}]
6:$$moduleReference(ClientButton)
```

서버에서 클라이언트로 정보를 보낼 때 기본적으로 스트리밍을 통해 조각 단위로 보내게 되는데 J0 같은 접두사가 하나의 조각 -> **청크(chunk)**를 의미하며 J, M, S와 같은 알파벳이 청크 타입을 의미한다.

이 청크 단위로 클라이언트로 전송되고 또 클라이언트에선 청크 단위로 받아서 역직렬화 후 렌더링하여 Fiber tree의 일부로 재구성한다(점진적 렌더링 -> 빠른 속도).

또한 필요시 청크 단위로 나중에 다운로드 받거나 하는게 가능하다

-> (참고로 RSC 청크 단위와 Fiber가 처리하는 렌더링 단위(청크)와는 다르다).

## Json-like 데이터란?

JSON-like는 JSON과 유사한 구조지만, JSON에서 허용되지 않는 데이터(함수, Symbol 등)가 포함될 수도 있는 데이터 형식이다.

# 클라이언트로 가는 데이터 흐름

## 1. 서버에서 React Server Component를 실행

- 데이터베이스 조회, API 호출 등을 수행.
- 서버 컴포넌트는 서버에서 실행되고, HTML이 아닌 **RSC 페이로드(JSON-like)**로 직렬화 된다.
- RSC 페이로드는 컴포넌트 트리 구조와 `props`, 어디에 어떤 클라이언트 컴포넌트가 어느 위치에 삽입될 지에 대한 정보 등을 담고 있다.

## 2. 서버가 클라이언트로 RSC 페이로드 및 데이터 전송

- 서버는 초기 HTML(SSR/SSG)과 RSC Payload 그리고 클라이언트 컴포넌트가 담긴 JS 번들을 클라이언트로 전송 한다.

RSC 페이로드는 스트리밍 방식으로 전달될 수 있어서, 클라이언트가 받은 데이터를 즉시 렌더링하면서, 남은 데이터를 계속 받아올 수 있다. 즉, 서버가 RSC 트리 일부를 계산하면 곧바로 클라이언트로 흘려보내고, 클라이언트는 받은 부분부터 점진적으로 UI를 채워 넣는다.

참고로 Next.js의 서버 컴포넌트의 기본 전송 방식이 스트리밍 방식이다.

## 3. 클라이언트에서 해석

- 브라우저가 초기 HTML을 렌더링하여 화면에 표시한다.
- RSC Payload 받아서 React가 UI를 갱신한다.
- JS 번들 로드 후 상호작용을 활성화(Hydration)한다.

</br>
</br>

<!-- 수정 -->

# 클라이언트 컴포넌트에 서버 컴포넌트를 불러올 수 없는 이유?

## 1. 실행 환경이 다르다

- **서버 컴포넌트**

  서버에서만 실행됨 → DB 쿼리, 파일 시스템 접근, 비밀 키 사용 가능

- **클라이언트 컴포넌트**

  브라우저에서 실행됨 → window, DOM API 사용 가능
  ➡️ 클라이언트 쪽 코드 번들에 서버 코드가 섞이면, 브라우저가 실행할 수 없는 코드(DB 쿼리 등)가 들어가 버리기 때문에 실행할 수 없을 뿐더러 보안 문제가 생길 수 있다.

## 2. 번들링 과정에서 충돌

- Next.js(RSC 아키텍처)는 서버용 번들과 클라이언트용 번들을 따로 생성함.

- 만약 클라이언트 컴포넌트에서 서버 컴포넌트를 import하면 → 빌드 타임에 클라이언트 번들 안에 서버 코드가 섞여 들어가려 하는데 이건 설계상 불가능하기 때문에 빌드 에러 발생.

## 3. 데이터 흐름 제약(단방향)

<!-- ? -->

- React RSC 모델에서는:

  - 서버 컴포넌트 → 클라이언트 컴포넌트 import ✅ 가능

  - 클라이언트 컴포넌트 → 서버 컴포넌트 import ❌ 불가능

- 이유: 서버는 렌더링 시점에 클라이언트 컴포넌트를 포함할 수 있지만, 클라이언트에서 서버 실행을 트리거할 방법은 없음.

- 즉, 서버 → 클라이언트로 내려보내는 건 직렬화가 되지만, 반대는 직렬화할 수 없음.

# 서버 컴포넌트에서 클라이언트 컴포넌트로 일반 함수를 전달할 수 없는 이유

## 직렬화 문제

- 서버 컴포넌트는 실행된 결과를 **RSC 페이로드(JSON-like 직렬화된 데이터)**로 클라이언트에 전송한다.

- 그런데 일반 함수는 직렬화할 수 없다 → JS 함수는 실행 컨텍스트, 클로저, 스코프 등을 포함하므로 JSON으로 안전하게 변환하는 것이 불가능하다.

- 따라서 클라이언트로 보내려 하면 직렬화 단계에서 에러 발생.

## 예외

- React 18.2 / Next.js 13.4+ 부터 도입된 서버 액션(서버 함수)을 이용하면, 서버 함수 참조를 클라이언트에 넘겨 마치 함수 전달처럼 쓸 수 있다.

- 이건 사실 함수 객체를 직접 직렬화하는 게 아니라, 서버에서 해당 함수를 식별할 수 있는 함수 ID/토큰만 클라이언트에 전달하는 방식이다.

- 클라이언트가 그 "가짜 함수"를 호출하면 → 서버에 POST 요청이 날아가서 진짜 함수가 실행되게 된다.
