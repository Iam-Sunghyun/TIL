<h2>목차</h2>

- [RSC(React Server Component)란?](#rscreact-server-component란)
- [RSC의 주요 특징](#rsc의-주요-특징)
  - [1. 서버에서 실행됨 (No JavaScript on Client)](#1-서버에서-실행됨-no-javascript-on-client)
  - [2. 데이터베이스 및 API 호출을 직접 수행 가능](#2-데이터베이스-및-api-호출을-직접-수행-가능)
  - [3. 서버에서만 실행 가능 (훅, 이벤트 핸들러 사용 불가)](#3-서버에서만-실행-가능-훅-이벤트-핸들러-사용-불가)
  - [4. 클라이언트 컴포넌트와 조합 가능](#4-클라이언트-컴포넌트와-조합-가능)
- [클라이언트 컴포넌트에 서버 컴포넌트를 불러올 수 없는 이유?](#클라이언트-컴포넌트에-서버-컴포넌트를-불러올-수-없는-이유)
  - [1. 실행 환경이 다르다](#1-실행-환경이-다르다)
  - [2. 번들링 과정에서 충돌](#2-번들링-과정에서-충돌)
  - [3. 데이터 흐름 제약(단방향)](#3-데이터-흐름-제약단방향)
- [서버 컴포넌트에서 클라이언트 컴포넌트로 일반 함수를 전달할 수 없는 이유](#서버-컴포넌트에서-클라이언트-컴포넌트로-일반-함수를-전달할-수-없는-이유)
  - [직렬화 문제](#직렬화-문제)
  - [예외](#예외)
- [RSC를 사용하는 이유는? (장점)](#rsc를-사용하는-이유는-장점)
  - [언제 RSC를 사용해야 할까?](#언제-rsc를-사용해야-할까)
  - [Reference](#reference)

# RSC(React Server Component)란?

**RSC(React Server Components)** 는 리액트 18v에서 추가 된 서버에서 실행되는 컴포넌트로, **브라우저에서 실행되지 않고 서버에서 실행 된 후 클라이언트로 전송된다**. 서버 컴포넌트는 **빌드 될 때 CI 서버에서 한 번 실행되거나(정적 렌더링인 경우), 각 요청마다 웹 서버를 통해 실행될 수 있다(렌더링 방식마다 상이).**

기존의 SSR(Server-Side Rendering)이나 CSR(Client-Side Rendering)과는 다른 개념이며, 클라이언트와 서버를 효과적으로 분리하여 성능을 최적화할 수 있다.

리액트에서 기본으로 활성화되진 않으며 보통 Next.js 같은 프레임워크를 통해 사용된다. **Next.js 13+ 에선 기본이 서버 컴포넌트이다.**

# RSC의 주요 특징

## 1. 서버에서 실행됨 (No JavaScript on Client)

- 서버 컴포넌트는 서버 측에서 실행되며, 실행 후 만들어진 **RSC 페이로드(RSC Payload)** 는 JSON 형태의 데이터로, 클라이언트에 다운로드 되는 자바스크립트 번들에 포함되지 않고 별도의 fetch 요청으로 전달된다.
- 더 가벼운 페이지 로드가 가능해진다.

## 2. 데이터베이스 및 API 호출을 직접 수행 가능

- 보통 서버로 데이터를 페칭하는 일을 담당하여 리액트로 백엔드 구성이 가능해진다.
- 써드 파티 라이브러리를 클라이언트 측에서 다운 받을 필요 없이 서버 측에서만 다운 받아 호출함으로서 클라이언트로 전송되는 자바스크립트 크기를 줄일 수 있다.

```
import db from "@/lib/db";

export default async function UserProfile() {
  const user = await db.user.findFirst();

  return <div>Welcome, {user.name}!</div>;
}
```

## 3. 서버에서만 실행 가능 (훅, 이벤트 핸들러 사용 불가)

- 서버 컴포넌트에서 `useEffect`, `useState`, 클라이언트 전용 훅과 이벤트 핸들러 같은 함수를 사용 할 수 없다. 이유는 서버 컴포넌트는 서버 사이드에서 렌더링 되고 반환 값(RSC 페이로드)이 브라우저에 전달된다. 즉, 컴포넌트 자체는 클라이언트로 전송되지 않기 때문에 렌더링 혹은 사용자 상호작용이 허용되지 않는다.

```
"use client"; // 클라이언트 컴포넌트로 설정

import { useState } from "react";

export default function ClientComponent() {
  const [count, setCount] = useState(0);

  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;
}
```

## 4. 클라이언트 컴포넌트와 조합 가능

- `use client`를 추가하면 클라이언트 컴포넌트로 변경 가능하다.
- 클라이언트 컴포넌트는 서버 컴포넌트 내에서 import하여 사용 가능하며 서버 컴포넌트에서 데이터를 받아서 props를 통해 클라이언트 컴포넌트로 넘겨줄 수 있다.
- 클라이언트 컴포넌트 내에 서버 컴포넌트를 렌더링 하려면 서버 컴포넌트의 자식인 클라이언트 컴포넌트 하위에 서버 컴포넌트를 전달해주면 된다.

```
// Server Component
import ClientComponent from "./ClientComponent";

export default async function ServerComponent() {
  const data = await fetch("https://jsonplaceholder.typicode.com/todos/1").then(
    (res) => res.json()
  );

  return <ClientComponent title={data.title} />;
}
------------------------------------------
// Client Component
"use client"; // 클라이언트 컴포넌트로 설정

import { useState } from "react";

export default function ClientComponent({ title }: { title: string }) {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>{title}</h1> {/* 서버에서 받은 데이터 사용 */}
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increase</button>
    </div>
  );
}
```

# 클라이언트 컴포넌트에 서버 컴포넌트를 불러올 수 없는 이유?

## 1. 실행 환경이 다르다

- **서버 컴포넌트**

  서버에서만 실행됨. DB 쿼리, 파일 시스템 접근, 비밀 키, Node.js API 등 사용 가능.

- **클라이언트 컴포넌트**

  브라우저에서 실행됨 → window, DOM API 사용 가능.
  ➡️ 클라이언트 쪽 코드 번들에 서버 코드가 섞이면, 브라우저가 실행할 수 없는 코드(DB 쿼리 등)가 들어가 버리기 때문에 실행할 수 없을 뿐더러 보안 문제가 생길 수 있다.

## 2. 번들링 과정에서 충돌

- Next.js(RSC 아키텍처)는 서버 용 번들과 클라이언트 용 번들을 따로 생성함.

- 만약 클라이언트 컴포넌트에서 서버 컴포넌트를 import하면 → 빌드 타임에 클라이언트 번들 안에 서버 코드가 섞여 들어가려 하는데 서버 컴포넌트의 실행 결과물은 JSON 형태(RSC 페이로드)이기 때문에 클라이언트에서 import로 가져올 수 없다.

## 3. 데이터 흐름 제약(단방향)

- React RSC 모델에서는:

  - 서버 컴포넌트 → 클라이언트 컴포넌트 import ✅ 가능

  - 클라이언트 컴포넌트 → 서버 컴포넌트 import ❌ 불가능

- 이유: 서버 컴포넌트는 서버에서 실행되어 RSC 페이로드(JSON-like) 형태로 클라이언트에 전송되며, 컴포넌트 자체는 전송되지 않는다. 따라서 클라이언트 컴포넌트 내에 서버 컴포넌트는 클라이언트 측에서 실행 할 수가 없다.

</br>

# 서버 컴포넌트에서 클라이언트 컴포넌트로 일반 함수를 전달할 수 없는 이유

## 직렬화 문제

- 서버 컴포넌트는 실행된 결과를 **RSC 페이로드(JSON-like 직렬화된 데이터)** 로 클라이언트에 전송한다.

- 그런데 일반 함수는 직렬화 할 수 없다. → JS 함수는 실행 컨텍스트, 클로저, 스코프 등을 포함하므로 JSON으로 안전하게 변환하는 것이 불가능하다.

- 따라서 클라이언트로 보내려 하면 직렬화 단계에서 에러가 발생한다.

## 예외

- React 18.2 / Next.js 13.4+ 부터 도입된 서버 액션(서버 함수)을 이용하면, 서버 함수 참조를 클라이언트에 넘겨 마치 함수 전달처럼 쓸 수 있다.

- 이건 사실 함수 객체를 직접 직렬화 하는 게 아니라, 서버에서 해당 함수를 식별할 수 있는 함수 ID/토큰만 클라이언트에 전달하는 방식이다.

- 클라이언트가 서버 함수를 호출하면 서버에 POST 요청이 날아가서 진짜 함수가 실행되게 된다.

**[직렬화 가능 인수]**

https://ko.react.dev/reference/rsc/use-server#serializable-parameters-and-return-values

</br>

# RSC를 사용하는 이유는? (장점)

<h3>✅성능 최적화</h3>

- 서버에서 실행되어 RSC 페이로드를 생성 후 브라우저로 전송하므로 불필요한
  JavaScript 전송을 줄임.
- 클라이언트에 전송되는 JavaScript 번들 크기가 감소하여 로딩 속도가 빨라짐.

<h3>✅데이터 페칭 최적화</h3>

- 서버에서 API 요청을 처리하므로, 클라이언트에서 별도의 API 요청이 필요 없음(서버와 클라이언트의 역할 분리).
- 네트워크 요청을 줄이고 백엔드와 직접 연결 가능.
<!-- <h3>✅SEO 최적화</h3>


- 서버에서 미리 HTML을 렌더링하여 검색 엔진 크롤러가 쉽게 읽을 수 있음.
- CSR보다 SEO에 유리. -->
<h3>✅보안 강화</h3>

- API 키, 데이터베이스 연결 정보 등이 클라이언트에 노출되지 않음.

## 언제 RSC를 사용해야 할까?

- ✅ 데이터베이스에서 직접 데이터를 가져와야 할 때.
<!-- - ✅ SEO 최적화가 중요한 경우 (검색 엔진 노출 필요). -->
- ✅ 서버에서만 실행해야 하는 로직이 있을 때 (예: API 키 보안 유지).

- ✅ 불필요한 JavaScript 번들 크기를 줄이고 싶을 때.

<!-- 리액트 서버 컴포넌트는 서버에서만 렌더링되는 컴포넌트로, 클라이언트 측에서는 자바스크립트가 필요하지 않습니다. 서버에서 HTML을 생성하여 클라이언트에 전달하며, 이는 페이지 로딩 속도를 개선하고 클라이언트 측의 자원 사용을 줄이는 데 도움이 됩니다. 클라이언트와 서버가 각각의 역할을 분담하여, 효율적이고 빠른 웹 애플리케이션을 구축할 수 있도록 지원합니다. -->

</br>

## Reference

https://www.freecodecamp.org/korean/news/how-to-use-react-server-components/

https://nextjs.org/docs/app/building-your-application/rendering/server-components

https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns

https://tech.kakaopay.com/post/react-server-components/

https://yozm.wishket.com/magazine/detail/2271/
