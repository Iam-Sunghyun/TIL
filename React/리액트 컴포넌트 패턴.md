<h2>목차</h2>

- [컴포넌트 재사용 옵션](#컴포넌트-재사용-옵션)
- [렌더링 `props` 패턴](#렌더링-props-패턴)
- [HOC(Higher Order Component, 고차 컴포넌트) 패턴](#hochigher-order-component-고차-컴포넌트-패턴)
- [Compount componenets 패턴](#compount-componenets-패턴)

# 컴포넌트 재사용 옵션

리액트에서 재사용할 수 있는 옵션은 크게 2가지가 있다.

1. UI 재사용

컴포넌트와 `props`를 사용하여 UI를 재사용할 수 있다. 자주 사용되는 컴포넌트를 따로 정의하거나 `children` `props`를 사용해 래퍼 컴포넌트를 정의하는 방법이 있다.

2. 상태 로직 재사용(사용자 정의 훅 사용)

리액트 내장 훅을 포함하는 로직을 사용자 정의 훅으로 추출하여 재사용성을 높이는 방법이다. 자주 사용되는 로직을 따로 정의하여 재사용성과 코드 간결함, 유지 보수성을 높일 수 있다.

위 2가지 옵션을 수행하기 위해 리액트의 특성을 이용하여 패턴화한 것들이 있는데 대표적으로 다음과 같다.

# 렌더링 `props` 패턴

<!-- 헷갈 -->

렌더링될 컴포넌트를 반환하는 함수를 `props`로 전달하여 재사용성을 높이는 패턴.

리액트 훅이 없을때(16.8v 이전) 흔히 사용되던 패턴이다.

다음은 렌더링 `props` 패턴의 예시이다.

```
// 렌더링 props 패턴 이전
function List({ title, items }) {
  const [isOpen, setIsOpen] = useState(true);
  const [isCollapsed, setIsCollapsed] = useState(false);

  const displayItems = isCollapsed ? items.slice(0, 3) : items;

  function toggleOpen() {
    setIsOpen((isOpen) => !isOpen);
    setIsCollapsed(false);
  }

  return (
    <div className="list-container">
      <div className="heading">
        <h2>{title}</h2>
        <button onClick={toggleOpen}>
          {isOpen ? <span>&or;</span> : <span>&and;</span>}
        </button>
      </div>
      {isOpen && (
        <ul className="list">
          {displayItems.map((product) => (
            <ProductItem key={product.productName} product={product} />
          ))}
        </ul>
      )}

      <button onClick={() => setIsCollapsed((isCollapsed) => !isCollapsed)}>
        {isCollapsed ? `Show all ${items.length}` : "Show less"}
      </button>
    </div>
  );
}

export default function App() {
  return (
    <div>
      <h1>Render Props Demo</h1>

      <div className="col-2">
        <List title="Products" items={products} />
      </div>
    </div>
  );
}
-----------------------------------------
// List에 렌더링 될 컴포넌트를 함수로 전달
function ProductItem({ product }) {
  return (
    <li className="product">
      <p className="product-name">{product.productName}</p>
      <p className="product-price">${product.price}</p>
      <p className="product-description">{product.description}</p>
    </li>
  );
}

function CompanyItem({ company, defaultVisibility }) {
  const [isVisible, setIsVisisble] = useState(defaultVisibility);

  return (
    <li
      className="company"
      onMouseEnter={() => setIsVisisble(true)}
      onMouseLeave={() => setIsVisisble(false)}
    >
      <p className="company-name">{company.companyName}</p>
      {isVisible && (
        <p className="company-phrase">
          <strong>About:</strong> {company.phrase}
        </p>
      )}
    </li>
  );
}

function List({ title, items, render }) {
  const [isOpen, setIsOpen] = useState(true);
  const [isCollapsed, setIsCollapsed] = useState(false);

  const displayItems = isCollapsed ? items.slice(0, 3) : items;

  function toggleOpen() {
    setIsOpen((isOpen) => !isOpen);
    setIsCollapsed(false);
  }

  return (
    <div className="list-container">
      <div className="heading">
        <h2>{title}</h2>
        <button onClick={toggleOpen}>
          {isOpen ? <span>&or;</span> : <span>&and;</span>}
        </button>
      </div>
      {isOpen && <ul className="list">{displayItems.map(render)}</ul>}

      <button onClick={() => setIsCollapsed((isCollapsed) => !isCollapsed)}>
        {isCollapsed ? `Show all ${items.length}` : "Show less"}
      </button>
    </div>
  );
}

export default function App() {
  return (
    <div>
      <h1>Render Props Demo</h1>

      <div className="col-2">
        <List
          title="Products"
          items={products}
          render={(product) => (
            <ProductItem key={product.productName} product={product} />
          )}
        />
        <List
          title="Companies"
          items={companies}
          render={(company) => (
            <CompanyItem
              key={company.productName}
              company={company}
              defaultVisibility={false}
            />
          )}
        />
      </div>
    </div>
  );
}
```

위 2번째 코드처럼 `List`에 렌더링 될 컴포넌트를 `render` `props`에 함수로 전달하였다. 이로서 `products` 값에 종속되있던 `List` 컴포넌트는 컴포넌트 반환 함수로 전달되는 내용을 렌더링하는 컴포넌트로서 재사용 가능하게 된다.

# HOC(Higher Order Component, 고차 컴포넌트) 패턴

<!-- 자주 사용되지 않는듯. 수정 필 이해안됨 -->

리액트 훅이 나오고 나선 최근엔 거의 사용되지 않는 패턴.

다음 예시에선 `ProductList`라는 이름의 변경할 수 없는 써드 파티 라이브러리 컴포넌트가 있다고 가정한다.

```
function ProductList({ title, items }) {
  return (
    <ul className="list">
      {items.map((product) => (
        <ProductItem key={product.productName} product={product} />
      ))}
    </ul>
  );
}
```

# Compount componenets 패턴

<!-- 수정 필 이해부족-->

여러 컴포넌트를 포함한 하나의 상위 컴포넌트를 정의하는 방법?
재사용성과 유연성을 위해 사용

1. 컨텍스트 생성
2. 부모 컴포넌트 생성
3. 수행할 작업을 위한 자식 컴포넌트생성
4. 부모 컴포넌트 `props`로 자식 컴포넌트 전달(선택?)

```
import { useState, createContext, useContext } from "react";

// 1. 컨텍스트 생성
const CounterContext = createContext();

// 2. 부모 컴포넌트 생성
function Counter({ children }) {
  const [count, setCount] = useState(0);
  const increase = () => setCount((c) => c + 1);
  const decrease = () => setCount((c) => c - 1);

  return (
    <CounterContext.Provider value={{ count, increase, decrease }}>
      <span>{children}</span>
    </CounterContext.Provider>
  );
}

// 3. 자식 컴포넌트 생성
function Count() {
  const { count } = useContext(CounterContext);
  return <span>{count}</span>;
}
function Label({ children }) {
  return <span>{children}</span>;
}
function Increase({ icon }) {
  const { increase } = useContext(CounterContext);
  return <button onClick={increase}>{icon}</button>;
}
function Decrease({ icon }) {
  const { decrease } = useContext(CounterContext);
  return <button onClick={decrease}>{icon}</button>;
}

// 4. 부모 컴포넌트 프로퍼티에 자식 컴포넌트 추가
Counter.Count = Count;
Counter.Label = Label;
Counter.Increase = Increase;
Counter.Decrease = Decrease;

export default Counter;
---------------------------------------
import Counter from "./Counter";

export default function App() {
  return (
    <div>
      <h1>Compound Component Pattern</h1>
      {/* <Counter
        iconIncrease="+"
        iconDecrease="-"
        label="My NOT so flexible counter"
        hideLabel={false}
        hideIncrease={false}
        hideDecrease={false}
      /> */}
      <Counter>
        <Counter.Increase icon="+" />
        <Counter.Count />
        <Counter.Decrease icon="-" />
        <Counter.Label icon="-">My super flexible counter</Counter.Label>
      </Counter>
    </div>
  );
}
```
