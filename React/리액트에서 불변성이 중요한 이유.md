# 불변성(Immutablity)이란?

불변성이란 메모리에 저장된 값을 변경할 수 없는 것을 말한다. 자바스크립트에서 불변성을 갖는 값들은 `Number`, `String` 과 같은 원시 값들이다.

불변 값이 저장된 변수는 값 자체를 변경할 수는 없고, 재할당으로만 값을 변경(교체) 할 수 있다. 만약 재할당이 불가능한 `const` 변수에 원시 값(불변 값)를 저장하면, 변수의 값을 아예 변경할 수 없다.

## 불변성(Immutablity)의 이점

우선 자바스크립트에서 불변성의 이점을 알아본다.

불변성을 갖는 원시 값의 경우 메모리에 저장된 값을 변경할 수 없다. 따라서 변수에 원시 값이 저장된 경우 재할당을 통해서만 변경할 수 있는데(엄밀히는 교체하는 것) 이러한 특징은 다음과 같은 장점이 있다.

1. 예기치 못한 원본의 변경으로 인한(부수효과로 인한) 잠재적인 버그를 방지한다.
2. 데이터 신뢰성을 보장한다. -> 데이터를 예측하기 쉽고 그에 따라 테스트하기도 쉽다.

## 리액트에서 불변성이 중요한 이유?

React 공식 문서에는 배열이나 객체와 같은 참조를 통해 접근하는 변경 가능(mutable) 데이터들도 원시 값처럼 읽기 전용으로 즉, 불변 값(immutable value)으로 취급하라고 되어있다.

배열 상태 변수로 예를 들면 `arr[0] = 'bird'`, `push()`, `pop()` 같이 직접 변경하거나 요소를 추가, 삭제하는게 아닌 새로운 배열로 재할당해야 한다는 것이다(물론 `push()` 메서드와 같은 방법으로 직접 변경이 동작하지 않는 것은 아니다).

리액트 공식 문서에서 말하는 불변성의 장점은 다음과 같다.

1. 이전 상태 재사용: 직접적인 데이터 변형을 피하면 이전 버전의 데이터를 그대로 유지하고 나중에 재사용할 수 있습니다. -> 불변성을 유지하면 시간 여행(time-travel)과 취소 기능(undo/redo)을 구현하기가 더 쉽습니다. 이전 상태와 현재 상태를 유지하고 변경 사항을 쉽게 추적할 수 있기 때문에 이전 상태로 돌아가거나 다시 앞으로 되돌릴 수 있는 기능을 구현하는 것이 용이하다.  
   
2. 효율적인 상태 변경 감지: 불변성은 컴포넌트의 데이터가 변경되었는지 여부를 비교하는 데 매우 저렴합니다. -> 참조 값 변경 여부만으로 쉽게 변경을 감지할 수 있기 때문(`Object.is`로 얕은 비교).

3. 예측 가능성으로 코드 작성 및 디버깅 용이: 불변성을 유지하면 상태 변경을 예측할 수 있습니다. 객체나 배열을 직접 수정하면 어떤 부분이 변경되었는지 추적하기가 어렵고, 의도하지 않은 부작용이 발생할 수 있습니다. 하지만 불변성을 유지하면 이전 상태와 현재 상태의 차이를 쉽게 파악할 수 있으며, 상태의 변화를 추적하고 이해하기가 더 쉬워집니다

리액트는 상태 변경을 얕은 비교(`Object.is`)를 통해 감지한다. 즉, 참조를 저장하는 객체, 배열과 같은 데이터의 경우 참조가 변경되었을 때 변경으로 감지하고, 렌더링을 트리거한다. 

만약 값을 직접 변경하면 변경을 감지하지 못해 컴포넌트 렌더링이 발생하지 않는다. 또한  `React.memo`를 사용한 하위 컴포넌트에서도 `props`의 변경을 제대로 감지하지 못하게 된다.

<!-- immer, immutable.js-->
```
리액트(React)에서 불변성(Immutability)을 유지하는 것은 매우 중요한 이유가 있습니다:

효율적인 업데이트 감지: 리액트는 가상 DOM(Virtual DOM)을 사용하여 컴포넌트의 변경사항을 비교하고 필요한 경우에만 업데이트를 수행합니다. 이때 이전 상태와 현재 상태를 비교하여 변경된 부분만 실제 DOM에 반영합니다. 불변성을 유지하면 이전 상태와 현재 상태를 쉽게 비교할 수 있어 업데이트를 더 효율적으로 감지할 수 있습니다. 객체나 배열을 직접적으로 수정하는 것보다는 새로운 객체나 배열을 생성하여 변경사항을 반영하는 것이 더 효율적입니다.

예측 가능한 상태 관리: 불변성을 유지하면 상태 변경을 예측할 수 있습니다. 객체나 배열을 직접 수정하면 어떤 부분이 변경되었는지 추적하기가 어렵고, 의도하지 않은 부작용이 발생할 수 있습니다. 하지만 불변성을 유지하면 이전 상태와 현재 상태의 차이를 쉽게 파악할 수 있으며, 상태의 변화를 추적하고 이해하기가 더 쉬워집니다.

참조 비교를 통한 성능 최적화: 리액트에서는 컴포넌트의 상태나 속성(props)이 변경되었는지를 판단하기 위해 참조 비교(Reference comparison)를 수행합니다. 즉, 이전 상태와 현재 상태를 직접 비교하여 변경 여부를 판단합니다. 불변성을 유지하면 상태나 속성의 참조가 변경되기 때문에 참조 비교를 통해 변경 여부를 빠르게 확인할 수 있습니다. 반면에 객체나 배열을 직접 수정하면 참조가 변경되지 않기 때문에 리액트가 변경사항을 감지하기 위해 더 많은 비교 연산을 수행해야 하므로 성능이 저하될 수 있습니다.

시간 여행과 취소 기능 지원: 불변성을 유지하면 시간 여행(time-travel)과 취소 기능(undo/redo)을 구현하기가 더 쉽습니다. 이전 상태와 현재 상태를 유지하고 변경 사항을 쉽게 추적할 수 있기 때문에 이전 상태로 돌아가거나 다시 앞으로 되돌릴 수 있는 기능을 구현하는 것이 용이합니다.
```

## Reference

**[React.js에서 불변성을 사용할 때의 장단점(얕은 비교 이유 깊은 비교와 성능 차이)]**

https://reactkungfu.com/2015/08/pros-and-cons-of-using-immutability-with-react-js/

**[React 얕은 비교 코드]**

https://github.com/facebook/react/blob/v16.8.6/packages/shared/shallowEqual.js

**[React docs 불변성을 권장하는 이유]**

https://react.dev/learn/updating-objects-in-state#why-is-mutating-state-not-recommended-in-react

https://beta.reactjs.org/learn/tutorial-tic-tac-toe#why-immutability-is-important

**[불변성이 중요한 이유]**

https://stackoverflow.com/questions/34385243/why-is-immutability-so-important-or-needed-in-javascript

https://velopert.com/3486


**[React docs Updating Arrays in State]**

https://beta.reactjs.org/learn/updating-arrays-in-state#making-other-changes-to-an-array

**[부수효과와 순수함수]** 

https://maxkim-j.github.io/posts/js-pure-function/