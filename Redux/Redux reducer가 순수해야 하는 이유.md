<h2>목차</h2>

- [`Redux`의 `reducer`가 순수해야 하는 이유?](#redux의-reducer가-순수해야-하는-이유)
  - [1. `Redux DevTools` time-travel debugging](#1-redux-devtools-time-travel-debugging)
  - [2. `Redux`와 `React-Redux` 리렌더링 신뢰성](#2-redux와-react-redux-리렌더링-신뢰성)
  - [3. 비결정적 로직, 사이드 이펙트 차단으로 예측 가능한 코드](#3-비결정적-로직-사이드-이펙트-차단으로-예측-가능한-코드)
  - [4. 비동기 로직의 분리로 코드 복잡도 감소](#4-비동기-로직의-분리로-코드-복잡도-감소)
  - [리덕스에서 리듀서가 순수해야 하는 이유, 상태 불변성을 지켜야 하는 이유 요약](#리덕스에서-리듀서가-순수해야-하는-이유-상태-불변성을-지켜야-하는-이유-요약)

# `Redux`의 `reducer`가 순수해야 하는 이유?

## 1. `Redux DevTools` time-travel debugging

`Redux`만의 강점이라고 할 수 있는 것은 브라우저의 `Redux DevTools` 확장 프로그램을 사용해 마치 버전 관리 시스템처럼 `store`에 저장된 `state`의 변경 히스토리를 확인하고, 또 원하는 지점으로 돌아갈 수 있다는 것!(공식 문서에서는 **'time-travel debugging'** 이라 표현한다).

여기서 **상태가 변경되는 것을 제대로 기록하기 위해서는 `reducer`는 순수 함수로 작성되어야 한다.** 그러기 위해서 하지 말아야 할 것은 다음과 같다.

<!-- - 리듀서에서 상태를 직접 변경하는 것.
- HTTP 요청, 데이터베이스 호출, API 호출, 전역 변수 사용과 같은 부수효과를 내는 작업(API 호출의 경우 외부에 의존하는 것이며 외부 코드를 가져와 사용하는 것이 가독성을 떨어트릴 수 있다).
- 순수하지 않은 함수 호출, 예: `Date.now()` 또는 `Math.random()` -->

| 비순수 행위        | 예시                     | 이유                         |
| ------------------ | ------------------------ | ---------------------------- |
| 상태 직접 변경     | `state.todos.push(...)`  | 불변성 깨짐, React 감지 불가 |
| 랜덤값 사용        | `Math.random()`          | 매번 결과 달라짐             |
| 시간 사용          | `Date.now()`             | 같은 액션이라도 결과 다름    |
| 네트워크 요청      | `fetch('/api')`          | 외부 부작용                  |
| 로컬 스토리지 접근 | `localStorage.setItem()` | 부작용, 테스트 불가          |

## 2. `Redux`와 `React-Redux` 리렌더링 신뢰성

`Redux`와 `React-Redux`는 성능을 위해 모두 **일치 연산자(`===`)를 통한 얕은 평등 검사(shallow equality checking)를 하기 때문에 상태를 새 값으로 교체하지 않게 되면 변경을 감지하지 못해 컴포넌트 렌더링이 발생하지 않는다.**

이렇게 불변성 유지를 위해 매번 새 객체를 생성하고 할당하는 것이 성능에 문제가 될 것 같지만 새 객체를 할당하는 방식으로 상태 변경 여부를 쉽게 판단할 수 있기 때문에 프로퍼티를 대조하며 비교하는 것보다 훨씬 성능 면에서 유리하다고 한다.

```
// Redux 공식 문서
성능이나 다른 이유 때문에 위해 순수하지 않은 리듀서를 작성하는 것도 기술적으로는 가능하지만, 이렇게 하지 않을 것을 권장합니다. 순수하지 않은 리듀서 구현은 시간 여행, 기록/재생, 핫 로딩과 같은 개발 지원 기능을 망가뜨립니다. 더욱이 불변성 때문에 대부분의 실제 애플리케이션에서 성능 문제가 있을 것 같아보이지만, Om이 증명했듯이 객체 할당에 있어서 성능에서 불리할 지라도 순수 함수를 통해 무엇이 바뀌었는지 쉽게 판단할 수 있기 때문에 재렌더링이나 재계산 같은 값비싼 연산을 피한다는 점에서는 여전히 유리합니다.
```

## 3. 비결정적 로직, 사이드 이펙트 차단으로 예측 가능한 코드

같은 입력에 대해 결과가 항상 일정 해야 테스트를 할 수 있는데 리듀서가 순수 하지 않다면, `fetch`, `Date.now()`와 같은 API가 있다면 테스트 결과가 매번 달라 질 수 있다. 이러한 코드는 애플리케이션이 커짐에 따라 복잡성이 증가하고 예측하기 어렵게 만들어 유지 보수에 좋지 않다

결국 순수한 리듀서는 예측 가능한 결과물로 테스트, 디버깅을 쉽게 만든다.

```
// jest 테스트 코드 예시
expect(reducer({ count: 1 }, { type: 'INCREMENT' })).toEqual({ count: 2 });
```

## 4. 비동기 로직의 분리로 코드 복잡도 감소

3번과 어느 정도 겹치는 내용. 외부에 의존, 변경하지 않는 리듀서는 예측하기 어려운 상태 변경으로 인한 버그를 방지하고, 비동기 작업(주로 HTTP 요청)을 분리 함으로서 코드 복잡도를 감소 시킨다.

따라서 부수효과(API 호출, ID 생성, 랜덤 값, 시간)는 액션 생성자/미들웨어/Thunk/Effect layer에서 처리하는 식으로 리듀서 바깥에서 수행하도록 해야 한다.

## 리덕스에서 리듀서가 순수해야 하는 이유, 상태 불변성을 지켜야 하는 이유 요약

- 이전 상태를 기록하여 시간여행 디버깅, 핫 리로딩과 같은 강력한 기능을 사용하기 위해
- 예측하기 어려운 상태 변경으로 인한 버그 방지
- 상태 변경을 얕은 비교로 감지하기 때문(변경을 확인하기 위한 로직이 훨씬 간단하므로 빠르다)
- 비동기 작업을 따로 분리하여 리듀서 로직 복잡도 감소

</br>

<!-- # 리듀서에 http 요청 넣으면 안되는 이유?

http 요청이 있는 함수는 순수함수가 될 수 없다. 외부(서버) 상태를 변경하고 동일한 입력에 대해 다른 결과를 만들어 낼 수 있기 때문. 예를 들면 응답 실패, 혹은 POST, DELETE, PUT과 같은 메서드로 인한 부수효과로 **결과를 예측하기 어려워진다.**

- 순수성 유지: Redux Reducer는 순수한 함수로 작성되어야 한다. 순수 함수는 입력에 대해 항상 동일한 결과를 반환하고 외부 상태를 변경하지 않습니다. HTTP 요청은 외부 상태에 의존하고 비동기적인 성격을 가지므로 순수성을 유지할 수 없습니다. **Reducer에서 HTTP 요청을 수행하면 같은 입력에 대해 다른 결과를 반환하게 되어 예측 불가능성과 디버깅, 단위 테스트의 어려움을 초래할 수 있습니다.**

- 동기성 요구: Redux는 동기적인 상태 관리를 지향합니다. Reducer는 동기적으로 실행되어야 하며, 상태 업데이트는 순차적으로 이루어져야 합니다. **하지만 HTTP 요청은 비동기적으로 처리되며, 결과를 바로 반환하지 않는다. 요청이 완료되기 전까지 기다려야 합니다. 이로 인해 Reducer가 블로킹(blocking)되고 애플리케이션의 응답성이 저하될 수 있습니다.**

- 상태 관리 분리: Redux는 상태 관리를 단일한 지점에 집중시키는 아키텍처 패턴입니다. **Reducer는 순수한 상태 변이 로직에 집중되어야 하며, HTTP 요청과 같은 비동기 작업은 다른 레이어에서 처리되어야 합니다.**(유지보수 용이) 이를 위해 Redux Middleware를 사용하여 비동기 작업을 관리하고 상태 업데이트를 Reducer에게 디스패치하는 방식으로 분리할 수 있습니다.

따라서, Redux Reducer에 HTTP 요청을 직접 넣으면 예측할 수 없는 동작, 동기성 요구의 위배(혹은 블록킹), 상태 관리 분리의 어려움 등 다양한 문제가 발생할 수 있습니다. 대신에 redux-thunk, redux-saga, redux-observable과 같은 Redux Middleware를 활용하여 비동기 작업을 처리하고 Reducer는 상태를 변화시키는 데에만 집중하는 것이 권장되는 패턴입니다.

Redux Middleware는 Redux 액션을 가로채고, 비동기 작업을 수행한 후에 적절한 액션을 디스패치하여 상태를 업데이트합니다. -->

**[Why is immutability required by Redux?]**

https://redux.js.org/faq/immutable-data#why-is-immutability-required-by-redux

https://ko.redux.js.org/faq/immutable-data

https://ko.redux.js.org/understanding/history-and-design/prior-art/#flux

https://www.freecodecamp.org/news/why-redux-needs-reducers-to-be-pure-functions-d438c58ae468/
