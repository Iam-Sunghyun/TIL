<h2>목차</h2>

- [`Redux`의 `reducer`가 순수해야 하는 이유?](#redux의-reducer가-순수해야-하는-이유)
- [리듀서에 http 요청 넣으면 안되는 이유?](#리듀서에-http-요청-넣으면-안되는-이유)
  - [그렇다면 순수 함수(pure function)에서 비동기 작업을 수행하면 안 되는 이유?](#그렇다면-순수-함수pure-function에서-비동기-작업을-수행하면-안-되는-이유)

# `Redux`의 `reducer`가 순수해야 하는 이유?

`Redux`만의 강점이라고 할 수 있는 것은 브라우저의 `Redux DevTools` 확장 프로그램을 사용해 마치 버전 관리 시스템처럼 `store`에 저장된 `state`의 변경 히스토리를 확인하고, 또 원하는 지점으로 돌아갈 수 있다는 것!(공식 문서에서는 **'time-travel debugging'** 이라 표현한다).

여기서 **상태가 변경되는 것을 제대로 기록하기 위해서는 `reducer`는 순수 함수로 작성되어야 한다.** 그러기 위해서 하지 말아야 할 것들은 다음과 같다.

1. 리듀서에서 상태를 직접 변경하는 것.
2. HTTP 요청, 데이터베이스 호출, API 호출, 전역 변수 사용과 같은 부수효과를 내는 작업(API 호출의 경우 외부에 의존하는 것이며 외부 코드를 가져와 사용하는 것이 가독성을 떨어트릴 수 있다).
3. 순수하지 않은 함수 호출, 예: Date.now() 또는 Math.random()

`Redux`와 `React-Redux`는 성능을 위해 모두 **얕은 평등 검사(shallow equality checking)를 사용하기 때문에** 상태를 새 값으로 교체하지 않게 되면 변경을 감지하지 못해 컴포넌트 렌더링이 발생하지 않는다.

```
성능이나 다른 이유 때문에 위해 순수하지 않은 리듀서를 작성하는 것도 기술적으로는 가능하지만, 이렇게 하지 않을 것을 권장합니다. 순수하지 않은 리듀서 구현은 시간 여행, 기록/재생, 핫 로딩과 같은 개발 지원 기능을 망가뜨립니다. 더욱이 불변성 때문에 대부분의 실제 애플리케이션에서 성능 문제가 있을 것 같아보이지만, Om이 증명했듯이 객체 할당에 있어서 성능에서 불리할 지라도 순수 함수를 통해 무엇이 바뀌었는지 쉽게 판단할 수 있기 때문에 재렌더링이나 재계산 같은 값비싼 연산을 피한다는 점에서는 여전히 유리합니다.
```

**<h2>리덕스에서 리듀서가 순수해야 하는 이유, 상태 불변성을 지켜야 하는 이유 요약</h2>**

- 이전 상태를 기록하여 시간여행 디버깅, 핫 리로딩과 같은 강력한 기능을 사용하기 위해
- 예측하기 어려운 상태 변경으로 인한 버그 방지
- 상태 변경을 얕은 비교로 감지하기 때문(변경을 확인하기 위한 로직이 훨씬 간단하므로 빠르다)

# 리듀서에 http 요청 넣으면 안되는 이유?

<!-- 내용 수정 필 -->

http요청이 있는 함수는 순수함수가 될 수 없다. 외부(서버) 상태를 변경하고 동일한 입력에 대해 다른 결과를 만들어 낼 수 있기 때문. 예를 들면 응답 실패, 혹은 POST, DELETE, PUT과 같은 메서드로 인한 부수효과로 결과를 예측하기 어려워진다

- 순수성 유지: Redux Reducer는 순수한 함수로 작성되어야 합니다. 순수 함수는 입력에 대해 항상 동일한 결과를 반환하고 외부 상태를 변경하지 않습니다. HTTP 요청은 외부 상태에 의존하고 비동기적인 성격을 가지므로 순수성을 유지할 수 없습니다. Reducer에서 HTTP 요청을 수행하면 같은 입력에 대해 다른 결과를 반환하게 되어 예측 불가능성과 디버깅, 단위 테스트의 어려움을 초래할 수 있습니다.

<!-- 이부분 다소 모호함 비동기 작업을 하면 안되는 이유? 이벤트 루프에 의존하기 때문에? -->

- 동기성 요구: Redux는 동기적인 상태 관리를 지향합니다. Reducer는 동기적으로 실행되어야 하며, 상태 업데이트는 순차적으로 이루어져야 합니다. 하지만 HTTP 요청은 비동기적으로 처리되며, 결과를 바로 반환하지 않는다. 요청이 완료되기 전까지 기다려야 합니다. 이로 인해 Reducer가 블로킹(blocking)되고 애플리케이션의 응답성이 저하될 수 있습니다.

- 상태 관리 분리: Redux는 상태 관리를 단일한 지점에 집중시키는 아키텍처 패턴입니다. Reducer는 순수한 상태 변이 로직에 집중되어야 하며, HTTP 요청과 같은 비동기 작업은 다른 레이어에서 처리되어야 합니다. 이를 위해 Redux Middleware를 사용하여 비동기 작업을 관리하고 상태 업데이트를 Reducer에게 디스패치하는 방식으로 분리할 수 있습니다.

따라서, Redux Reducer에 HTTP 요청을 직접 넣으면 예측할 수 없는 동작, 동기성 요구의 위배, 상태 관리 분리의 어려움 등 다양한 문제가 발생할 수 있습니다. 대신에 redux-thunk, redux-saga, redux-observable과 같은 Redux Middleware를 활용하여 비동기 작업을 처리하고 Reducer는 상태를 변화시키는데에만 집중하는 것이 권장되는 패턴입니다.

Redux Middleware는 Redux 액션을 가로채고, 비동기 작업을 수행한 후에 적절한 액션을 디스패치하여 상태를 업데이트합니다.

## 그렇다면 순수 함수(pure function)에서 비동기 작업을 수행하면 안 되는 이유?

- 예측 가능성: 순수 함수는 동일한 입력에 대해 항상 동일한 출력을 반환해야 합니다. 이는 함수의 예측 가능성을 보장하고 디버깅을 용이하게 만듭니다. 비동기 작업은 외부 상태나 시간에 따라 결과가 달라질 수 있으므로, 순수성을 해칠 수 있습니다.

- 부수효과: 비동기 작업은 주로 외부의 상태를 변경하거나 부작용을 발생시키는 경향이 있습니다. 순수 함수는 외부 상태를 변경하지 않고 입력에만 의존해 결과를 반환하는 반면, 비동기 작업은 외부 상태를 변경하거나 함수 외부에 영향을 줄 수 있습니다. 이는 코드의 복잡성을 증가시키고 예상치 못한 동작을 초래할 수 있습니다.

- 동기성 요구: 순수 함수는 동기적으로 실행되며, 함수 호출이 끝날 때까지 대기하지 않고 즉시 값을 반환합니다. 비동기 작업은 완료되기를 기다려야 하고, 이는 함수의 동작을 차단하고 응답성을 저하시킬 수 있습니다.

따라서, 순수 함수는 비동기 작업을 수행하지 않아야 합니다. 비동기 작업은 순수 함수의 결과를 의존적으로 처리하고 상태 변경을 담당하는 다른 메커니즘인 콜백 함수, 프로미스, async/await 등을 사용하여 처리해야 합니다. 이를 통해 예측 가능성과 순수성을 유지하면서 비동기 작업을 효과적으로 처리할 수 있습니다.

**[Why is immutability required by Redux?]**

https://redux.js.org/faq/immutable-data#why-is-immutability-required-by-redux

https://ko.redux.js.org/faq/immutable-data

https://ko.redux.js.org/understanding/history-and-design/prior-art/#flux

https://www.freecodecamp.org/news/why-redux-needs-reducers-to-be-pure-functions-d438c58ae468/
